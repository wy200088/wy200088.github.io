<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Blue&#39;s caveolae</title>
  
  <subtitle>今日买菜（1/1）..</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-10-30T10:13:21.283Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>WyAndLjy</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>多态的有关讲解</title>
    <link href="http://yoursite.com/2019/10/24/%E5%A4%9A%E6%80%81%E7%9A%84%E6%9C%89%E5%85%B3%E8%AE%B2%E8%A7%A3/"/>
    <id>http://yoursite.com/2019/10/24/多态的有关讲解/</id>
    <published>2019-10-24T11:11:37.000Z</published>
    <updated>2019-10-30T10:13:21.283Z</updated>
    
    <content type="html"><![CDATA[<h3 id="JAVA多态讲解"><a href="#JAVA多态讲解" class="headerlink" title="JAVA多态讲解"></a>JAVA多态讲解</h3><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>什么叫多态？多态就是一种事物可以有多种表现形式</p><h3 id="多态三要素"><a href="#多态三要素" class="headerlink" title="多态三要素"></a>多态三要素</h3><p>1.被动方必须有继承关系</p><p>2.子类一般都要重写父类方法</p><p>3.必须将主动方的功能函数的参数设置为 被动方父类的类型</p><h3 id="举个例子司机开车"><a href="#举个例子司机开车" class="headerlink" title="举个例子司机开车"></a>举个例子司机开车</h3><p> 假如说司机会开汽车  我们需要定义个汽车的类  然后在司机类中添加会开汽车的的方法<br>假如说司机会开卡车 我们需要再定义一个卡车的类  然后在司机类中添加会开卡车的方法下面看下传统的调用方式  代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`<span class="class"><span class="keyword">class</span>` `<span class="title">Car</span>``</span>&#123;``    ``<span class="keyword">private</span>` `String name;` `    ``<span class="comment">//无参 构造方法``    ``public` `Car()&#123;&#125;``    ``// 有参构造方法``    ``public` `Car(String name)&#123;``        ``this``.name = name;``    ``&#125;``    ``public` `void` `setName(String name)&#123;``        ``this``.name = name;``    ``&#125;``    ``public` `String getName()&#123;``        ``return` `this``.name;``    ``&#125;``    ``public` `void` `run()&#123;&#125;``&#125;` `class` `Bus ``extends` `Car``&#123;``    ``public` `Bus()&#123;&#125;``    ``public` `Bus(String name)&#123;``        ``super``(name);``    ``&#125;``    ``public` `void` `run()&#123;``        ``System.out.println(``"公交车在跑"``);``    ``&#125;``&#125;` `class` `SmallCar ``extends` `Car``&#123;``    ``public` `SmallCar()&#123;&#125;``    ``public` `SmallCar(String name)&#123;``        ``super``(name);``    ``&#125;``    ``public` `void` `run()&#123;``        ``System.out.println(``"小轿车在跑"``);``    ``&#125;``&#125;` `class` `Drivers``&#123;``    ``//假如司机会开公交车``    ``public` `void` `driverBus(Bus b)&#123;``        ``b.run();``    ``&#125;` `    ``//假如司机会开小轿车``    ``public` `void` `driverSmallCar(SmallCar smcar)&#123;``        ``smcar.run();``    ``&#125;``&#125;`   `class`  `TestDt``&#123;``    ``public` `static` `void` `main(String[] args)``    ``&#123;``        ``Drivers d = ``new` `Drivers();``        ` `        ``//司机开公交车``        ``d.driverBus(``new` `Bus(``"公交车"``));``        ``d.driverSmallCar(``new` `SmallCar(``"小轿车"``));``    ``&#125;``&#125;`</span></span><br></pre></td></tr></table></figure><p> 正如上面的列子 在添加司机开其他的车 就会重复上面的行为 缺点是 扩展性比较差，后期代码维护困难。</p><p><strong>然后我们用多态的写法优化上述例子 代码如下：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`<span class="class"><span class="keyword">class</span>` `<span class="title">Car</span>``</span>&#123;``    ``<span class="keyword">private</span>` `String name;` `    ``<span class="comment">//无参 构造方法``    ``public` `Car()&#123;&#125;``    ``// 有参构造方法``    ``public` `Car(String name)&#123;``        ``this``.name = name;``    ``&#125;``    ``public` `void` `setName(String name)&#123;``        ``this``.name = name;``    ``&#125;``    ``public` `String getName()&#123;``        ``return` `this``.name;``    ``&#125;``    ``public` `void` `run()&#123;&#125;``&#125;` `class` `Bus ``extends` `Car``&#123;``    ``public` `Bus()&#123;&#125;``    ``public` `Bus(String name)&#123;``        ``super``(name);``    ``&#125;``    ``public` `void` `run()&#123;``        ``System.out.println(``"公交车在跑"``);``    ``&#125;``&#125;` `class` `SmallCar ``extends` `Car``&#123;``    ``public` `SmallCar()&#123;&#125;``    ``public` `SmallCar(String name)&#123;``        ``super``(name);``    ``&#125;``    ``public` `void` `run()&#123;``        ``System.out.println(``"小轿车在跑"``);``    ``&#125;``&#125;` `class` `Drivers``&#123;``    ``public` `void` `driverCar(Car car)&#123;``        ``car.run();``    ``&#125;``&#125;`   `class`  `TestDt``&#123;``    ``public` `static` `void` `main(String[] args)``    ``&#123;``        ``Drivers d = ``new` `Drivers();``        ` `        ``d.driverCar(``new` `Bus(``"公交车"``));``        ``d.driverCar(``new` `SmallCar(``"小轿车"``));``    ``&#125;``&#125;`</span></span><br></pre></td></tr></table></figure><p> 比较第一种写法  假如司机还会开其他的车 只需要添加会开这种车的类就行  司机类不需要再添加其它功能方法 。代码简介  后期维护比较方便  这种编写多态的形式也叫向上转型。</p><p>但是要想调用子类独有的方法必须向下转型才能调用</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;JAVA多态讲解&quot;&gt;&lt;a href=&quot;#JAVA多态讲解&quot; class=&quot;headerlink&quot; title=&quot;JAVA多态讲解&quot;&gt;&lt;/a&gt;JAVA多态讲解&lt;/h3&gt;&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
    
      <category term="JAVA面向对象" scheme="http://yoursite.com/categories/JAVA%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
    
      <category term="JAVA多态" scheme="http://yoursite.com/tags/JAVA%E5%A4%9A%E6%80%81/"/>
    
  </entry>
  
  <entry>
    <title>HTML 3D讲解</title>
    <link href="http://yoursite.com/2019/10/22/HTML-3D%E8%AE%B2%E8%A7%A3/"/>
    <id>http://yoursite.com/2019/10/22/HTML-3D讲解/</id>
    <published>2019-10-22T12:51:20.000Z</published>
    <updated>2019-10-30T10:15:30.822Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Html里的3D"><a href="#Html里的3D" class="headerlink" title="Html里的3D"></a>Html里的3D</h3><p>CSS3中的3D变换主要包括以下几种功能函数： 3D位移：CSS3中的3D位移主要包括translateZ()和translate3d()两个功能函数；  3D旋转：CSS3中的3D旋转主要包括rotateX()、rotateY()、rotateZ()和rotate3d()四个功能函数；  3D缩放：CSS3中的3D缩放主要包括scaleZ()和scale3d()两个功能函数；</p><p>景深</p><p>生活中的3d 区别于2d的地方</p><p>近大远小 景深程序中实现的方法 perspective 元素距离 视线的距离（物体和眼睛的距离越小，近大远小的效果越明显）perspective: 1200px;（在父元素中使用）transform:perspective(1200px) （在子元素中使用）两个都设置会发生冲突，建议只设置父元素，通常的数值在900-1200之间 如果当你的视线距离物体足够远的时候，基本上就不会有近大远小的感觉</p><p>perspective-origin;</p><p>观察3d元素的（位置）角度 perspective-origin：center center （中心）perspective-origin：left top （左上角）perspective-origin：100% 100% （右下角）</p><p>transform-style属性</p><p>transform-style属性是3D空间一个重要属性，指定嵌套元素如何在3D空间中呈现。他主要有两个属性值：flat和preserve-3d其中flat值为默认值，表示所有子元素在2D平面呈现。preserve-3d表示所有子元素在3D空间中呈现。也就是说，如果对一个元素设置了transform-style的值为flat，则该元素的所有子元素都将被平展到该元素的2D平面中进行呈现。沿着X轴或Y轴方向旋转该元素将导致位于正或负Z轴位置的子元素显示在该元素的平面上，而不是它的前面或者后面。如果对一个元素设置了transform-style的值为preserve-3d，它表示不执行平展操作，他的所有子元素位于3D空间中。</p><p>3d重要功能函数</p><p>1、 3D位移</p><p>在CSS3中3D位移主要包括两种函数translateZ()和translate3d()。translate3d()函数使一个元素在三维空间移动。 语法：translate3d(tx,ty,tz) tx：代表横向坐标位移向量的长度； ty：代表纵向坐标位移向量的长度； tz：代表Z轴位移向量的长度。此值不能是一个百分比值，如果取值为百分比值，将会认为无效值。 ranslateZ()函数的功能是让元素在3D空间沿Z轴进行位移。语法：translateZ(t) t：指的是Z轴的向量位移长度。</p><p>2、 3D旋转</p><p>在三维变形中，我们可以让元素在任何轴旋转。为此，CSS3新增三个旋转函数：rotateX()、rotateY()、rotateZ()和rotate3d(x,y,z,a)。</p><p>rotateX(a)</p><p>rotateX()函数指定一个元素围绕X轴旋转，旋转的量被定义为指定的角度；如果值为正值，元素围绕X轴顺时针旋转；反之，如果值为负值，元素围绕X轴逆时针旋转。</p><p>rotateY(a)</p><p>rotateY()函数指定一个元素围绕Y轴旋转，旋转的量被定义为指定的角度；如果值为正值，元素围绕Y轴顺时针旋转；反之，如果值为负值，元素围绕Y轴逆时针旋转。</p><p>rotateZ(a)</p><p>rotateZ()函数和其他两个函数功能一样的，区别在于rotateZ()函数指定一个元素围绕Z轴旋转。</p><p>rotate3d(x,y,z,a)</p><p>x：是一个0到１之间的数值，主要用来描述元素围绕X轴旋转的矢量值；y：是一个０到１之间的数值，主要用来描述元素围绕Y轴旋转的矢量值；z：是一个０到１之间的数值，主要用来描述元素围绕Z轴旋转的矢量值；a：是一个角度值，主要用来指定元素在3D空间旋转的角度，如果其值为正值，元素顺时针旋转，反之元素逆时针旋转。 </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Html里的3D&quot;&gt;&lt;a href=&quot;#Html里的3D&quot; class=&quot;headerlink&quot; title=&quot;Html里的3D&quot;&gt;&lt;/a&gt;Html里的3D&lt;/h3&gt;&lt;p&gt;CSS3中的3D变换主要包括以下几种功能函数： 3D位移：CSS3中的3D位移主要包括tra
      
    
    </summary>
    
    
      <category term="Web3D" scheme="http://yoursite.com/categories/Web3D/"/>
    
    
      <category term="Web" scheme="http://yoursite.com/tags/Web/"/>
    
  </entry>
  
  <entry>
    <title>JAVA知识点总结</title>
    <link href="http://yoursite.com/2019/10/13/JAVA%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2019/10/13/JAVA知识点总结/</id>
    <published>2019-10-13T14:25:14.000Z</published>
    <updated>2019-10-30T10:13:12.646Z</updated>
    
    <content type="html"><![CDATA[<h3 id="JAVA面向对象知识点总结"><a href="#JAVA面向对象知识点总结" class="headerlink" title="JAVA面向对象知识点总结"></a>JAVA面向对象知识点总结</h3><p>第二章 类和对象</p><ul><li>1.面向对象概念：</li><li>2.类的创建</li><li>语法：public class 类名{}</li><li>File—&gt;new—&gt;class—&gt;类名</li><li>3.创建对象</li><li>类名 对象名=new 类名();</li><li>对象名.方法名(); 对象名.属性</li><li>4.构造方法：方法名和类名相同,没有返回值</li><li>public class 类名{</li><li>public 类名(){}//主要的做用是初始化操作</li><li>}</li><li>5.构造方法重载</li><li>在同一个类中，方法名相同，参数个数，顺序，类型不相同的构造方法</li><li>public class 类名{</li><li>public 类名(){}</li><li>public 类名(String name,int age){}</li><li>}</li><li>6.构造方法的执行</li><li>new 类名();—&gt;执行构造方法</li><li>super();—&gt;执行了父类的构造方法</li><li>7.static静态修饰符</li><li>静态修饰符可以修饰属性，方法，代码块</li><li>类名.属性      类名.方法名</li><li>8.java内存（栈和堆，static，方法区，gc（垃圾回收机制））</li><li></li><li>第三章 面向对象三大特征—封装</li><li>1.封装的概念</li><li>2.封装的步骤</li><li>1.把属性私有化（private）</li><li>2.对这些属性设置get和set方法</li><li>3.调用处理这些方法</li><li>3.封装的作用：避免一些用一些不合乎常理的操作</li><li>4.修饰符</li><li>public—&gt;公共的：在一个项目中都可以访问，权限最高</li><li>private—&gt;私有的：只能在本类中进行访问，权限最低</li><li>protected—&gt;安全的，受保护的：同一个包能进行访问，继承中之类可以访问父类</li><li>default—&gt;默认的：同一个包能访问</li><li>第四章 面向对象三大特征—继承</li><li>1.继承的概念：父亲儿子，电影《西虹市首富》</li><li>2.继承的关键字：extends</li><li>3.继承的语法：</li><li>public class 类名  extends 父类{}</li><li>4.使用，在之类中：</li><li>可以直接调用父类的非私有属性和方法</li><li>可以用super.方法     super.属性</li><li>5.父类构造方法调用：super();</li><li>调用父类的构造方法必须在之类中调用</li><li>必须实在之类构造方法的第一行代码</li><li>6.重写@Override</li><li>必须继承</li><li>方法名一致，参数个数，顺序，类型全部一致<br> 第五章 面向对象（多态）</li><li>1.多态的概念</li><li>2.多态的必要条件</li><li>继承</li><li>重写</li><li>父类引用指向子类对象（向上转型）</li><li>3.多态的使用</li><li>public class Father{</li><li>public void cooking(){</li><li>System.out.println(“米饭”);</li><li>}</li><li>}</li><li>public class Son extends Father{</li><li>@Override</li><li>public void cooking(){</li><li>System.out.println(“熬粥”);</li><li>}</li><li>}</li><li>public class Test {</li><li>public static void main(String[] args) {</li><li>Father son=new Son();</li><li>son.cooking();</li><li>}</li><li>}</li><li>4.向下转型</li><li>Son son=(Son)father;</li><li>第六章 抽象</li><li>1.抽象的概念</li><li>2.抽象的关键字</li><li>abstract</li><li>可以修饰类，可以修饰方法</li><li>3.抽象的用法</li><li>//抽象类</li><li>public abstract class 类名{</li><li>//抽象方法没有方法体</li><li>public abstract void 方法名();    </li><li>}</li><li>//当父类是抽象类的时候，子类必须重写父类里面的抽象方法</li><li>4.final修饰符：最终的</li><li>修饰变量，修饰方法，修饰类</li><li>1.当修饰变量时，变量转换成常量，常量的值不能改变</li><li>final int a=18;//a=18;不能改变,必须给一个初始值</li><li>2.当修饰方法时，该方法不能被重写</li><li>3.当修饰类时，该类不能被继承</li><li>第七章 接口</li><li>1.接口的概念</li><li>2.接口的关键字</li><li>interface</li><li>3.接口的语法</li><li>public interface 接口名{}</li><li>File—&gt;new—&gt;interface//创建接口</li><li>4.接口的用法</li><li>实现接口的关键字  implements</li><li>public interface 接口名{</li><li>//接口是纯抽象类</li><li>//接口里面的方法都是抽象方法</li><li>void setData();</li><li>}</li><li>public class Play implements 接口名{</li><li>@Override</li><li>void setData(){</li><li>}</li><li>}</li><li>public class Test {</li><li>public static void main(String[] args) {</li><li>Play play=new Play();</li><li>play.setData();</li><li>}</li><li>}</li><li>注意接口可以进行多继承</li><li>public interface 接口名 extends 接口名，接口名{}</li><li>一般用法</li><li>public class 类名 extends 父类 implements 接口，接口{}</li><li>第八章 集合框架</li><li>1.ArrayList</li><li>1.用法</li><li>ArrayList list=new ArrayList();</li><li>list.add();//添加数据</li><li>list.get();//获取数据</li><li>2.Map</li><li>用法</li><li>Map map=new HasMap();</li><li>map.put(key,value);//key不能重复</li><li>map.get(key);//获取key对象的value</li><li>3.泛型</li><li>ArrayList<string> list=new ArrayList&gt;<string>();</string></string></li><li>Map&lt;String,String&gt; map=new HasMap&lt;String,String&gt;();</li><li>ArrayList&lt;Map&lt;String,String&gt;&gt; list=new ArrayList&gt;&lt;Map&lt;String,String&gt;&gt;();</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;JAVA面向对象知识点总结&quot;&gt;&lt;a href=&quot;#JAVA面向对象知识点总结&quot; class=&quot;headerlink&quot; title=&quot;JAVA面向对象知识点总结&quot;&gt;&lt;/a&gt;JAVA面向对象知识点总结&lt;/h3&gt;&lt;p&gt;第二章 类和对象&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1.面向
      
    
    </summary>
    
    
      <category term="JAVA面向对象" scheme="http://yoursite.com/categories/JAVA%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
    
      <category term="JAVA总结" scheme="http://yoursite.com/tags/JAVA%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
</feed>
