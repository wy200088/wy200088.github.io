<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Blue&#39;s caveolae</title>
  
  <subtitle>今日买菜（1/1）..</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-10-30T09:48:56.465Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>WyAndLjy</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>多态的有关讲解</title>
    <link href="http://yoursite.com/2019/10/24/%E5%A4%9A%E6%80%81%E7%9A%84%E6%9C%89%E5%85%B3%E8%AE%B2%E8%A7%A3/"/>
    <id>http://yoursite.com/2019/10/24/多态的有关讲解/</id>
    <published>2019-10-24T11:11:37.000Z</published>
    <updated>2019-10-30T09:48:56.465Z</updated>
    
    <content type="html"><![CDATA[<h3 id="JAVA多态讲解"><a href="#JAVA多态讲解" class="headerlink" title="JAVA多态讲解"></a>JAVA多态讲解</h3><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>什么叫多态？多态就是一种事物可以有多种表现形式</p><h3 id="多态三要素"><a href="#多态三要素" class="headerlink" title="多态三要素"></a>多态三要素</h3><p>1.被动方必须有继承关系</p><p>2.子类一般都要重写父类方法</p><p>3.必须将主动方的功能函数的参数设置为 被动方父类的类型</p><h3 id="举个例子司机开车"><a href="#举个例子司机开车" class="headerlink" title="举个例子司机开车"></a>举个例子司机开车</h3><p> 假如说司机会开汽车  我们需要定义个汽车的类  然后在司机类中添加会开汽车的的方法<br>假如说司机会开卡车 我们需要再定义一个卡车的类  然后在司机类中添加会开卡车的方法下面看下传统的调用方式  代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`<span class="class"><span class="keyword">class</span>` `<span class="title">Car</span>``</span>&#123;``    ``<span class="keyword">private</span>` `String name;` `    ``<span class="comment">//无参 构造方法``    ``public` `Car()&#123;&#125;``    ``// 有参构造方法``    ``public` `Car(String name)&#123;``        ``this``.name = name;``    ``&#125;``    ``public` `void` `setName(String name)&#123;``        ``this``.name = name;``    ``&#125;``    ``public` `String getName()&#123;``        ``return` `this``.name;``    ``&#125;``    ``public` `void` `run()&#123;&#125;``&#125;` `class` `Bus ``extends` `Car``&#123;``    ``public` `Bus()&#123;&#125;``    ``public` `Bus(String name)&#123;``        ``super``(name);``    ``&#125;``    ``public` `void` `run()&#123;``        ``System.out.println(``"公交车在跑"``);``    ``&#125;``&#125;` `class` `SmallCar ``extends` `Car``&#123;``    ``public` `SmallCar()&#123;&#125;``    ``public` `SmallCar(String name)&#123;``        ``super``(name);``    ``&#125;``    ``public` `void` `run()&#123;``        ``System.out.println(``"小轿车在跑"``);``    ``&#125;``&#125;` `class` `Drivers``&#123;``    ``//假如司机会开公交车``    ``public` `void` `driverBus(Bus b)&#123;``        ``b.run();``    ``&#125;` `    ``//假如司机会开小轿车``    ``public` `void` `driverSmallCar(SmallCar smcar)&#123;``        ``smcar.run();``    ``&#125;``&#125;`   `class`  `TestDt``&#123;``    ``public` `static` `void` `main(String[] args)``    ``&#123;``        ``Drivers d = ``new` `Drivers();``        ` `        ``//司机开公交车``        ``d.driverBus(``new` `Bus(``"公交车"``));``        ``d.driverSmallCar(``new` `SmallCar(``"小轿车"``));``    ``&#125;``&#125;`</span></span><br></pre></td></tr></table></figure><p> 正如上面的列子 在添加司机开其他的车 就会重复上面的行为 缺点是 扩展性比较差，后期代码维护困难。</p><p><strong>然后我们用多态的写法优化上述例子 代码如下：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`<span class="class"><span class="keyword">class</span>` `<span class="title">Car</span>``</span>&#123;``    ``<span class="keyword">private</span>` `String name;` `    ``<span class="comment">//无参 构造方法``    ``public` `Car()&#123;&#125;``    ``// 有参构造方法``    ``public` `Car(String name)&#123;``        ``this``.name = name;``    ``&#125;``    ``public` `void` `setName(String name)&#123;``        ``this``.name = name;``    ``&#125;``    ``public` `String getName()&#123;``        ``return` `this``.name;``    ``&#125;``    ``public` `void` `run()&#123;&#125;``&#125;` `class` `Bus ``extends` `Car``&#123;``    ``public` `Bus()&#123;&#125;``    ``public` `Bus(String name)&#123;``        ``super``(name);``    ``&#125;``    ``public` `void` `run()&#123;``        ``System.out.println(``"公交车在跑"``);``    ``&#125;``&#125;` `class` `SmallCar ``extends` `Car``&#123;``    ``public` `SmallCar()&#123;&#125;``    ``public` `SmallCar(String name)&#123;``        ``super``(name);``    ``&#125;``    ``public` `void` `run()&#123;``        ``System.out.println(``"小轿车在跑"``);``    ``&#125;``&#125;` `class` `Drivers``&#123;``    ``public` `void` `driverCar(Car car)&#123;``        ``car.run();``    ``&#125;``&#125;`   `class`  `TestDt``&#123;``    ``public` `static` `void` `main(String[] args)``    ``&#123;``        ``Drivers d = ``new` `Drivers();``        ` `        ``d.driverCar(``new` `Bus(``"公交车"``));``        ``d.driverCar(``new` `SmallCar(``"小轿车"``));``    ``&#125;``&#125;`</span></span><br></pre></td></tr></table></figure><p> 比较第一种写法  假如司机还会开其他的车 只需要添加会开这种车的类就行  司机类不需要再添加其它功能方法 。代码简介  后期维护比较方便  这种编写多态的形式也叫向上转型。</p><p>但是要想调用子类独有的方法必须向下转型才能调用</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;JAVA多态讲解&quot;&gt;&lt;a href=&quot;#JAVA多态讲解&quot; class=&quot;headerlink&quot; title=&quot;JAVA多态讲解&quot;&gt;&lt;/a&gt;JAVA多态讲解&lt;/h3&gt;&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
    
      <category term="JAVA面向对象" scheme="http://yoursite.com/categories/JAVA%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
    
      <category term="JAVA多态" scheme="http://yoursite.com/tags/JAVA%E5%A4%9A%E6%80%81/"/>
    
  </entry>
  
  <entry>
    <title>JAVA知识点总结</title>
    <link href="http://yoursite.com/2019/10/13/JAVA%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2019/10/13/JAVA知识点总结/</id>
    <published>2019-10-13T14:25:14.000Z</published>
    <updated>2019-10-14T07:43:59.831Z</updated>
    
    <content type="html"><![CDATA[<h3 id="JAVA面向对象知识点总结"><a href="#JAVA面向对象知识点总结" class="headerlink" title="JAVA面向对象知识点总结"></a>JAVA面向对象知识点总结</h3><p>第二章 类和对象</p><ul><li>1.面向对象概念：</li><li>2.类的创建</li><li>语法：public class 类名{}</li><li>File—&gt;new—&gt;class—&gt;类名</li><li>3.创建对象</li><li>类名 对象名=new 类名();</li><li>对象名.方法名(); 对象名.属性</li><li>4.构造方法：方法名和类名相同,没有返回值</li><li>public class 类名{</li><li>public 类名(){}//主要的做用是初始化操作</li><li>}</li><li>5.构造方法重载</li><li>在同一个类中，方法名相同，参数个数，顺序，类型不相同的构造方法</li><li>public class 类名{</li><li>public 类名(){}</li><li>public 类名(String name,int age){}</li><li>}</li><li>6.构造方法的执行</li><li>new 类名();—&gt;执行构造方法</li><li>super();—&gt;执行了父类的构造方法</li><li>7.static静态修饰符</li><li>静态修饰符可以修饰属性，方法，代码块</li><li>类名.属性      类名.方法名</li><li>8.java内存（栈和堆，static，方法区，gc（垃圾回收机制））</li><li></li><li>第三章 面向对象三大特征—封装</li><li>1.封装的概念</li><li>2.封装的步骤</li><li>1.把属性私有化（private）</li><li>2.对这些属性设置get和set方法</li><li>3.调用处理这些方法</li><li>3.封装的作用：避免一些用一些不合乎常理的操作</li><li>4.修饰符</li><li>public—&gt;公共的：在一个项目中都可以访问，权限最高</li><li>private—&gt;私有的：只能在本类中进行访问，权限最低</li><li>protected—&gt;安全的，受保护的：同一个包能进行访问，继承中之类可以访问父类</li><li>default—&gt;默认的：同一个包能访问</li><li>第四章 面向对象三大特征—继承</li><li>1.继承的概念：父亲儿子，电影《西虹市首富》</li><li>2.继承的关键字：extends</li><li>3.继承的语法：</li><li>public class 类名  extends 父类{}</li><li>4.使用，在之类中：</li><li>可以直接调用父类的非私有属性和方法</li><li>可以用super.方法     super.属性</li><li>5.父类构造方法调用：super();</li><li>调用父类的构造方法必须在之类中调用</li><li>必须实在之类构造方法的第一行代码</li><li>6.重写@Override</li><li>必须继承</li><li>方法名一致，参数个数，顺序，类型全部一致<br> 第五章 面向对象（多态）</li><li>1.多态的概念</li><li>2.多态的必要条件</li><li>继承</li><li>重写</li><li>父类引用指向子类对象（向上转型）</li><li>3.多态的使用</li><li>public class Father{</li><li>public void cooking(){</li><li>System.out.println(“米饭”);</li><li>}</li><li>}</li><li>public class Son extends Father{</li><li>@Override</li><li>public void cooking(){</li><li>System.out.println(“熬粥”);</li><li>}</li><li>}</li><li>public class Test {</li><li>public static void main(String[] args) {</li><li>Father son=new Son();</li><li>son.cooking();</li><li>}</li><li>}</li><li>4.向下转型</li><li>Son son=(Son)father;</li><li>第六章 抽象</li><li>1.抽象的概念</li><li>2.抽象的关键字</li><li>abstract</li><li>可以修饰类，可以修饰方法</li><li>3.抽象的用法</li><li>//抽象类</li><li>public abstract class 类名{</li><li>//抽象方法没有方法体</li><li>public abstract void 方法名();    </li><li>}</li><li>//当父类是抽象类的时候，子类必须重写父类里面的抽象方法</li><li>4.final修饰符：最终的</li><li>修饰变量，修饰方法，修饰类</li><li>1.当修饰变量时，变量转换成常量，常量的值不能改变</li><li>final int a=18;//a=18;不能改变,必须给一个初始值</li><li>2.当修饰方法时，该方法不能被重写</li><li>3.当修饰类时，该类不能被继承</li><li>第七章 接口</li><li>1.接口的概念</li><li>2.接口的关键字</li><li>interface</li><li>3.接口的语法</li><li>public interface 接口名{}</li><li>File—&gt;new—&gt;interface//创建接口</li><li>4.接口的用法</li><li>实现接口的关键字  implements</li><li>public interface 接口名{</li><li>//接口是纯抽象类</li><li>//接口里面的方法都是抽象方法</li><li>void setData();</li><li>}</li><li>public class Play implements 接口名{</li><li>@Override</li><li>void setData(){</li><li>}</li><li>}</li><li>public class Test {</li><li>public static void main(String[] args) {</li><li>Play play=new Play();</li><li>play.setData();</li><li>}</li><li>}</li><li>注意接口可以进行多继承</li><li>public interface 接口名 extends 接口名，接口名{}</li><li>一般用法</li><li>public class 类名 extends 父类 implements 接口，接口{}</li><li>第八章 集合框架</li><li>1.ArrayList</li><li>1.用法</li><li>ArrayList list=new ArrayList();</li><li>list.add();//添加数据</li><li>list.get();//获取数据</li><li>2.Map</li><li>用法</li><li>Map map=new HasMap();</li><li>map.put(key,value);//key不能重复</li><li>map.get(key);//获取key对象的value</li><li>3.泛型</li><li>ArrayList<string> list=new ArrayList&gt;<string>();</string></string></li><li>Map&lt;String,String&gt; map=new HasMap&lt;String,String&gt;();</li><li>ArrayList&lt;Map&lt;String,String&gt;&gt; list=new ArrayList&gt;&lt;Map&lt;String,String&gt;&gt;();</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;JAVA面向对象知识点总结&quot;&gt;&lt;a href=&quot;#JAVA面向对象知识点总结&quot; class=&quot;headerlink&quot; title=&quot;JAVA面向对象知识点总结&quot;&gt;&lt;/a&gt;JAVA面向对象知识点总结&lt;/h3&gt;&lt;p&gt;第二章 类和对象&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1.面向
      
    
    </summary>
    
    
    
  </entry>
  
</feed>
