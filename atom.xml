<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Blue&#39;s caveolae</title>
  
  <subtitle>今日买菜（1/1）..</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://wy200088.github.io/"/>
  <updated>2019-11-14T07:54:59.909Z</updated>
  <id>https://wy200088.github.io/</id>
  
  <author>
    <name>Blue</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java爬虫入门讲解</title>
    <link href="https://wy200088.github.io/2019/11/14/%E7%88%AC%E8%99%AB%E5%85%A5%E9%97%A8%E8%AE%B2%E8%A7%A3/"/>
    <id>https://wy200088.github.io/2019/11/14/爬虫入门讲解/</id>
    <published>2019-11-14T07:35:02.000Z</published>
    <updated>2019-11-14T07:54:59.909Z</updated>
    
    <content type="html"><![CDATA[<h3 id="爬虫简介"><a href="#爬虫简介" class="headerlink" title="爬虫简介"></a>爬虫简介</h3><p>随着互联网的迅速发展，网络资源越来越丰富，信息需求者如何从网络中抽取信息变得至关重要。目前，有效的获取网络数据资源的重要方式，便是网络爬虫技术。简单的理解，比如您对百度贴吧的一个帖子内容特别感兴趣，而帖子的回复却有1000多页，这时采用逐条复制的方法便不可行。而采用网络爬虫便可以很轻松地采集到该帖子下的所有内容。</p><p>网络爬虫技术最广泛的应用是在搜索引擎中，如百度、Google、Bing 等，它完成了搜索过程中的最关键的步骤，即网页内容的抓取。下图为简单搜索引擎原理图。</p><img src="http://images.gitbook.cn/38cdda70-7dce-11e8-be78-bb5c0f92d7f1" srcset="/img/loading.gif"><p>网络爬虫的作用，我总结为以下几点：</p><p>舆情分析：企业或政府利用爬取的数据，采用数据挖掘的相关方法，发掘用户讨论的内容、实行事件监测、舆情引导等。<br>企业的用户分析：企业利用网络爬虫，采集用户对其企业或商品的看法、观点以及态度，进而分析用户的需求、自身产品的优劣势、顾客抱怨等。<br>科研工作者的必备技术：现有很多研究都以网络大数据为基础，而采集网络大数据的必备技术便是网络爬虫。利用网络爬虫技术采集的数据可用于研究产品个性化推荐、文本挖掘、用户行为模式挖掘等。<br>网络爬虫涉及的领域包括:</p><h5 id="网络爬虫的基本概念"><a href="#网络爬虫的基本概念" class="headerlink" title="网络爬虫的基本概念"></a>网络爬虫的基本概念</h5><p>网络爬虫（Web Crawler），又称为网络蜘蛛（Web Spider）或 Web 信息采集器，是一种按照一定规则，自动抓取或下载网络信息的计算机程序或自动化脚本，是目前搜索引擎的重要组成部分。</p><p>狭义上理解：利用标准的 HTTP 协议，根据网络超链接（如<a href="https://www.baidu.com/）和" target="_blank" rel="noopener">https://www.baidu.com/）和</a> Web 文档检索的方法（如深度优先）遍历万维网信息空间的软件程序。</p><p>功能上理解：确定待爬的 URL 队列，获取每个 URL 对应的网页内容（如 HTML/JSON），解析网页内容，并存储对应的数据。</p><h5 id="网络爬虫的分类"><a href="#网络爬虫的分类" class="headerlink" title="网络爬虫的分类"></a>网络爬虫的分类</h5><p>网络爬虫按照系统架构和实现技术，大致可以分为以下几种类型：通用网络爬虫（General Purpose Web Crawler）、聚焦网络爬虫（Focused Web Crawler）、增量式网络爬虫（Incremental Web Crawler）、深层网络爬虫（Deep Web Crawler）。实际的网络爬虫系统通常是几种爬虫技术相结合实现的。</p><p>通用网络爬虫：爬行对象从一些种子 URL 扩充到整个 Web，主要为门户站点搜索引擎和大型 Web 服务提供商采集数据。</p><p>通用网络爬虫的爬取范围和数量巨大，对于爬行速度和存储空间要求较高，对于爬行页面的顺序要求较低，通常采用并行工作方式，有较强的应用价值。</p><p>聚焦网络爬虫，又称为主题网络爬虫：是指选择性地爬行那些与预先定义好的主题相关的页面。</p><p>和通用爬虫相比，聚焦爬虫只需要爬行与主题相关的页面，极大地节省了硬件和网络资源，保存的页面也由于数量少而更新快，可以很好地满足一些特定人群对特定领域信息的需求。</p><p>通常在设计聚焦网络爬虫时，需要加入链接和内容筛选模块。一个常见的案例是基于关键字获取符合用户需求的数据，如下图所示:</p><img src="http://images.gitbook.cn/48bb2780-7dce-11e8-be78-bb5c0f92d7f1" srcset="/img/loading.gif"><p>增量网络爬虫：对已下载网页采取增量式更新和只爬行新产生的或者已经发生变化网页的爬虫，它能够在一定程度上保证所爬行的页面是尽可能新的页面，历史已经采集过的页面不重复采集。</p><p>增量网络爬虫避免了重复采集数据，可以减小时间和空间上的耗费。通常在设计网络爬虫时，需要在数据库中，加入时间戳，基于时间戳上的先后，判断程序是否继续执行。</p><p>常见的案例有：论坛帖子评论数据的采集（如下图所示论坛的帖子，它包含400多页，每次启动爬虫时，只需爬取最近几天用户所发的帖子)；天气数据的采集；新闻数据的采集；股票数据的采集等。</p><img src="http://images.gitbook.cn/5ca25e80-7dce-11e8-8748-9f97e9dc7c3b" srcset="/img/loading.gif"><p>Deep Web 爬虫：指大部分内容不能通过静态链接获取，只有用户提交一些表单信息才能获取的 Web 页面。例如，需要模拟登陆的网络爬虫便属于这类网络爬虫。另外，还有一些需要用户提交关键词才能获取的内容，如京东淘宝提交关键字、价格区间获取产品的相关信息。</p><img src="http://images.gitbook.cn/6df35a40-7dce-11e8-be78-bb5c0f92d7f1" srcset="/img/loading.gif"><p>网络爬虫的流程<br>网络爬虫基本流程可用下图描述：</p><img src="http://images.gitbook.cn/7ec5d730-7dce-11e8-8a07-2345656531ad" srcset="/img/loading.gif"><p>具体流程为：</p><p>需求者选取一部分种子 URL（或初始 URL），将其放入待爬取的队列中。如在 Java 网络爬虫中，可以放入 LinkedList 或 List 中。<br>判断 URL 队列是否为空，如果为空则结束程序的执行，否则执行第三步骤。<br>从待爬取的 URL 队列中取出待爬的一个 URL，获取 URL 对应的网页内容。在此步骤需要使用响应的状态码（如200，403等）判断是否获取数据，如响应成功则执行解析操作；如响应不成功，则将其重新放入待爬取队列（注意这里需要移除无效 URL)。<br>针对已经响应成功后获取到的数据，执行页面解析操作。此步骤根据用户需求获取网页内容里的部分数据，如汽车论坛帖子的标题、发表的时间等。<br>针对3步骤已解析的数据，将其进行存储。<br>网络爬虫的爬行策略<br>一般的网络爬虫的爬行策略分为两种：深度优先搜索（Depth-First Search）策略、广度优先搜索（Breadth-First Search）策略。</p><p>深度优先搜索策略：从根节点的 URL 开始，根据优先级向下遍历该根节点对应的子节点。当访问到某一子节点 URL 时，以该子节点为入口，继续向下层遍历，直到没有新的子节点可以继续访问为止。接着使用回溯的方法，找到没有被访问到的节点，以类似的方式进行搜索。下图给出了理解深度优先搜索的一个简单案例：</p><img src="http://images.gitbook.cn/8fd1dab0-7dce-11e8-8a07-2345656531ad" srcset="/img/loading.gif"><p>广度优先搜索策略：也称为宽度优先，是另外一种非常有效的搜索技术，这种方法按照层进行遍历页面。下图可帮助理解广度优先搜索的遍历方式：</p><img src="http://images.gitbook.cn/a1410cd0-7dce-11e8-8748-9f97e9dc7c3b" srcset="/img/loading.gif"><p>基于广度优先的爬虫是最简单的爬取网站页面的方法，也是目前使用较为广泛的方法。在本达人课中，所讲的案例皆为宽度优先式的爬虫。</p><p>学习建议<br>网络爬虫是入门某一门编程语言的实战技术：很多学习编程语言（如 Java、Python 或 C++ 等）的同学，采用的方式只看书或在网络上看一些视频，而这将导致的后果就是面对一个具体项目时，不知道如何上手，尤其对新手而言。或者，一段时间后，就将之前的书本内容或视频内容遗忘了。</p><p>为此，我建议这些学习者可采用网络爬虫技术入门某一门编程语言（如 Java、Python)。因为爬虫技术是个综合性很强的技术，涉及到编程语言的很多方面。本达人课特别选用了 Java 作为开发语言，将带大家深入了解 Java 网络爬虫背后的核心技术。学完该课程，相信您也已很好地入门 Java 编程语言。</p><p>对于零基础入门 Java 网络爬虫的同学，在学习过程中请注意以下几点：</p><p>理解爬虫的基本原理。<br>学习 Java 网络爬虫涉及的基础知识：基础不牢，地动山摇，学习和掌握网络爬虫的基础知识很重要。<br>吃透基本的爬虫代码，并在此基础上进行改写。<br>不断实战，发现爬虫中涉及的新问题，并解决问题。<br>最后，提供一些书籍和资料，给入门以及想深入学习 Java 网络爬虫的读者：</p><p>《Java面向对象程序设计》（耿祥义、张跃平编著），由清华大学出版社出版，这是大学的教材，可作为基础学习。<br>《Java核心技术》全2册。<br>《Effective Java (3rd Edition)》：目前英文版已是第三版，中文版还在第二版，该书是 Java 进阶必备之书，英文比较好的同学可直接看英文版。<br>《自己动手写网络爬虫》（罗刚编著），国内第一本专门讲解 Java 网络爬虫的书籍。<br>参考文献<br>周立柱,林玲.聚焦爬虫技术研究综述[J].计算机应用,2005(09):1965-1969.<br>段平.面向web文本挖掘的主题搜索技术研究[D].西安电子科技大学,2008.<br>孙立伟, 何国辉, 吴礼发. 网络爬虫技术的研究[J]. 电脑知识与技术, 2010 (15): 4112-4115.<br>第02课：Java 网络爬虫基础知识<br>引言<br>Java 网络爬虫具有很好的扩展性可伸缩性，其是目前搜索引擎开发的重要组成部分。例如，著名的网络爬虫工具 Nutch 便是采用 Java 开发，该工具以 Apache Hadoop 数据结构为依托，提供了良好的批处理支持。</p><p>Java 网络爬虫涉及到 Java 的很多知识。本篇中将会介绍网络爬虫中需要了解的 Java 知识以及这些知识主要用于网络爬虫的哪一部分，具体包括以下内容：</p><p>Maven 的使用；<br>log4j 的使用；<br>对象的创建；<br>集合的使用；<br>正则表达式的使用；<br>HTTP 状态码；<br>其他。<br>Maven 的使用<br>Maven 是什么<br>Maven 是由 Apache 软件基金会所提供一款工具，用于项目管理及自动构建。我们知道在构建一个 Java 工程时，需要使用到很多 Jar 包，例如操作数据库需要使用到 mysql-connector-java 以及其相关依赖的 Jar 包。而 Maven 工具便可以很方便的对我们在项目中使用到的开源 Jar 包，进行很好的管理，比如下载某 Java 工程需要的 Jar 包及相关依赖 Java 包。</p><p>Maven 如何使用<br>Maven 使用项目对象模型（Project Object Model，POM）来配置，项目对象模型存储在名为 pom.xml 的文件中。以 Java 为例，我们可以在 Eclipse 中创建一个 Maven 工程。其中，Maven Dependencies 便存放着由 Maven 管理的 Jar 包。</p><img src="http://images.gitbook.cn/89ab4890-7dd5-11e8-8748-9f97e9dc7c3b" srcset="/img/loading.gif"><p>正如前面所说，构建一个 Java 工程需要使用很多 Jar 包，比如，在 Java 网络爬虫中，我们需要用到数据库连接、请求网页内容、解析网页内容的相关 Jar 包时，我们可以在上图所示的 pom 文件中添加如下语句：</p><p><code>&lt;dependency&gt;    &lt;groupId&gt;mysql&lt;/groupId&gt;    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;    &lt;version&gt;5.1.35&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.jsoup&lt;/groupId&gt;    &lt;artifactId&gt;jsoup&lt;/artifactId&gt;    &lt;version&gt;  1.8.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.apache.httpcomponents&lt;/groupId&gt;    &lt;artifactId&gt;httpclient &lt;/artifactId&gt;    &lt;version&gt;  4.2.3&lt;/version&gt;&lt;/dependency&gt;</code><br>之后，我们会惊讶地发现，工程的 Maven Dependencies 中自动下载了相关 Jar 包以及其依赖的 Jar 包。</p><img src="http://images.gitbook.cn/02792fd0-7dd6-11e8-be78-bb5c0f92d7f1" srcset="/img/loading.gif"><p>读者可以在 Maven Repository 网站中检索自己想要的 Jar 包，以及 Maven 操作语句。</p><img src="http://images.gitbook.cn/5bde78a0-7dd6-11e8-ab3b-8f5f773d8874" srcset="/img/loading.gif"><h5 id="log4j-的使用"><a href="#log4j-的使用" class="headerlink" title="log4j 的使用"></a>log4j 的使用</h5><h6 id="log4j-是什么"><a href="#log4j-是什么" class="headerlink" title="log4j 是什么"></a>log4j 是什么</h6><p>log4j 是一个基于 Java 的日志记录工具，曾是 Apache 软件基金会的一个项目。目前，日志是应用软件中不可或缺的部分。</p><p>log4j 怎么使用</p><ol><li>使用 Maven 下载 log4j 的 Jar 包，代码如下：</li></ol><p><dependency>    <groupid>log4j</groupid>    <artifactid>log4j</artifactid>    <version>1.2.17</version></dependency></p><ol start="2"><li>在 src 目录下创建 log4j.properties 文本文件，并做相关配置（关于每个配置的具体含义，读者可参考博文 《详细的 Log4j 使用教程》）:</li></ol><p>设置###log4j.rootLogger = debug,stdout,D,E### 输出信息到控制抬 ###log4j.appender.stdout = org.apache.log4j.ConsoleAppenderlog4j.appender.stdout.Target = System.outlog4j.appender.stdout.layout = org.apache.log4j.PatternLayoutlog4j.appender.stdout.layout.ConversionPattern = [%-5p] %d{yyyy-MM-dd HH:mm:ss,SSS} method:%l%n%m%n### 输出DEBUG 级别以上的日志到=error.log ###log4j.appender.D = org.apache.log4j.DailyRollingFileAppenderlog4j.appender.D.File = E://logs/log.loglog4j.appender.D.Append = truelog4j.appender.D.Threshold = DEBUG log4j.appender.D.layout = org.apache.log4j.PatternLayoutlog4j.appender.D.layout.ConversionPattern = %-d{yyyy-MM-dd HH:mm:ss}  [ %t:%r ] - [ %p ]  %m%n### 输出ERROR 级别以上的日志到=error.log ###log4j.appender.E = org.apache.log4j.DailyRollingFileAppenderlog4j.appender.E.File =E://logs/error.log log4j.appender.E.Append = truelog4j.appender.E.Threshold = ERROR log4j.appender.E.layout = org.apache.log4j.PatternLayoutlog4j.appender.E.layout.ConversionPattern = %-d{yyyy-MM-dd HH:mm:ss}  [ %t:%r ] - [ %p ]  %m%n</p><ol start="3"><li>实例程序，如下所示：</li></ol><p>package log4j;import org.apache.commons.logging.Log;import org.apache.commons.logging.LogFactory;public class Test {    static final Log logger = LogFactory.getLog(Test.class);    public static void main(String[] args) {        System.out.println(“hello”);        logger.info(“hello world”);        logger.debug(“This is debug message.”);         logger.warn(“This is warn message.”);        logger.error(“This is error message.”);      }}<br>基于此程序，我们就可以看到在我们工程的根目录下会产生一个日志文件 error.log 和 log.log。</p><img src="http://images.gitbook.cn/2ecfc890-7dd7-11e8-ab3b-8f5f773d8874" srcset="/img/loading.gif"><p>在网络爬虫中，我们可以使用日志记录程序可能出错的地方，监控程序的运行状态。</p><p>对象的创建<br>在 Java 中，经常使用 new 关键字来创建一个对象。例如，在爬取京东商品的id、product_name（商品名称）、price（价格）时，我们需要将每个商品的信息封装到对象里。</p><p>JdInfoModel jingdongproduct = new JdInfoModel();<br>在爬虫中，我们要操作 JdInfoModel 类中的变量（即id、product_name、price），可以使用 private 变量定义的方式。并且，使用 set() 与 get() 方法对数据进行设置（爬取数据的封装）和获取使用（爬取数据的存储）。下面的代码为 JdInfoModel 类：</p><p>package model;public class JdInfoModel {    private int id;    private String product_name;    private double price;    public int getId() {        return id;    }    public void setId(int id) {        this.id = id;    }    public String getProduct_name() {        return product_name;    }    public void setProduct_name(String product_name) {        this.product_name = product_name;    }    public double getPrice() {        return price;    }    public void setPrice(double price) {        this.price = price;    } }<br>集合的使用<br>网络爬虫离不开对集合的操作，这里涉及到 List、Set、Queue、Map 等集合的操作。</p><p>List 和 Set 集合的使用<br>List 的特征是其元素以线性方式存储，集合中可以存放重复对象。对比而言，Set 集合中的对象不按特定的方式排序，并且没有重复对象。在网络爬虫中，可以使用 List<string> 存储待爬的 URL 列表。例如：</string></p><p>//List集合的创建List<string> urllist = new ArrayList<string>();urllist.add(“<a href="https://movie.douban.com/subject/27608425&quot;);urllist.add(&quot;https://movie.douban.com/subject/26968024&quot;);//第一种遍历方式for" target="_blank" rel="noopener">https://movie.douban.com/subject/27608425&quot;);urllist.add(&quot;https://movie.douban.com/subject/26968024&quot;);//第一种遍历方式for</a>( String url : urllist ){    System.out.println(url);}//第二种遍历方式for( int i=0; i&lt;urllist.size(); i++ ){    System.out.println(i+”:”+urllist.get(i));}//第三种遍历方式Iterator<string> it = urllist.iterator();while ( it.hasNext() ){    System.out.println(it.next());}<br>同时我们也可以使用上面 List<jdinfomodel> 来封装具体的实例，即爬虫所采集到的数据。Set 集合的使用与 List 集合类似，这里就不过多讲解了。</jdinfomodel></string></string></string></p><p>Map 的使用<br>Map 是一种把键对象和值对象进行映射的集合，它的每一个元素都包含一对键对象和值对象，其中键对象不可以重复。Map 不仅在网络爬虫中常用，也常在文本挖掘算法的编写中使用。在网络爬虫中，可以使用 Map 过滤一些重复数据，但并建议使用 Map 对大规模数据去重过滤，原因是 Map 有空间大小的限制。比如，使用网络爬虫爬取帖子时，可能遇到置顶帖，而置顶帖可能会与下面的帖子重复出现。以下程序为 Map 的使用案例：</p><p> //Map的创建Map&lt;String,Integer&gt; map = new HashMap&lt;String,Integer&gt;();//值的添加，这里假设是爬虫中的产品id以及每个产品id对应的销售量map.put(“jd1515”, 100);map.put(“jd1516”, 300);map.put(“jd1515”, 100);map.put(“jd1517”, 200);map.put(“jd1518”, 100);//第一种方法遍历for (String key : map.keySet()) {      Integer value = map.get(key);      System.out.println(“Key = “ + key + “, Value = “ + value);  }  //第二种方法遍历Iterator&lt;Entry&lt;String, Integer&gt;&gt; entries = map.entrySet().iterator();  while (entries.hasNext()) {      Entry&lt;String, Integer&gt; entry = entries.next();      System.out.println(“Key = “ + entry.getKey() + “, Value = “ + entry.getValue());  }  //第三种方法遍历for (Entry&lt;String, Integer&gt; entry : map.entrySet()) {      System.out.println(“key= “ + entry.getKey() + “ and value= “ + entry.getValue());  }<br>Queue 的使用<br>队列（Queue）使用链表结构存储数据，是一种特殊的线性表，它只允许在表的前端进行删除操作，而在表的后端进行插入操作。LinkedList 类实现了 Queue 接口，因此我们可以把 LinkedList 当成 Queue 来用。Queue 常用来存待爬 URL 队列。</p><p>Queue<string> queue = new LinkedList<string>();//添加元素queue.offer(“<a href="https://www.douban.com/people/46077896/likes/topic/&quot;);queue.offer(&quot;https://www.douban.com/people/1475408/likes/topic&quot;);queue.offer(&quot;https://www.douban.com/people/3853295/likes/topic/&quot;);boolean" target="_blank" rel="noopener">https://www.douban.com/people/46077896/likes/topic/&quot;);queue.offer(&quot;https://www.douban.com/people/1475408/likes/topic&quot;);queue.offer(&quot;https://www.douban.com/people/3853295/likes/topic/&quot;);boolean</a> t = true;while (t) {    //如果Url队列为空,停止执行程序,否则请求Url    if( queue.isEmpty() ){        t = false;    }else {        //请求的url        String url = queue.poll();        System.out.println(url);        //这里要写请求数据,获取相应状态码，如果状态码为200,则解析数据;如果为404，url移除队列；否则该url重新如列    }<br>正则表达式的使用<br>正则表达式，是在解析数据（HTML 或 JSON 等)时，常用的方法。举个列子，我想从下面的语句中提取用户的 id（75975500）：</string></string></p><p><a href="//i.autohome.com.cn/75975500" target="_blank" class="linkblack">尊少来自沈阳</a><br>后面，我会介绍解析工具 jsoup，其可以解析获得“//i.autohome.com.cn/75975500”。接着，便可以使用正则表达式提取 75975500。</p><p>String url = “//i.autohome.com.cn/75975500”;String user_id = url.replaceAll(“\D”, “”);  //取代所有的非数字字符System.out.println(user_id);  //输出的结果即为75975500</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;爬虫简介&quot;&gt;&lt;a href=&quot;#爬虫简介&quot; class=&quot;headerlink&quot; title=&quot;爬虫简介&quot;&gt;&lt;/a&gt;爬虫简介&lt;/h3&gt;&lt;p&gt;随着互联网的迅速发展，网络资源越来越丰富，信息需求者如何从网络中抽取信息变得至关重要。目前，有效的获取网络数据资源的重要方式
      
    
    </summary>
    
    
      <category term="JAVA" scheme="https://wy200088.github.io/categories/JAVA/"/>
    
    
      <category term="JAVA爬虫入门" scheme="https://wy200088.github.io/tags/JAVA%E7%88%AC%E8%99%AB%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title>vue基础知识</title>
    <link href="https://wy200088.github.io/2019/11/13/vue%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <id>https://wy200088.github.io/2019/11/13/vue基础知识/</id>
    <published>2019-11-13T14:11:39.000Z</published>
    <updated>2019-11-13T14:24:19.612Z</updated>
    
    <content type="html"><![CDATA[<h2 id="实例-vue是由实例组成的"><a href="#实例-vue是由实例组成的" class="headerlink" title="实例-vue是由实例组成的"></a>实例-vue是由实例组成的</h2><p>根实例<br>组件也是实例</p><p>以$开头的单词都是代表着vue的实例属性实例方法</p><h2 id="vue实例中的生命周期钩子"><a href="#vue实例中的生命周期钩子" class="headerlink" title="vue实例中的生命周期钩子"></a>vue实例中的生命周期钩子</h2><p>8个生命周期函数<br>这几个函数不用放到methods里面</p><h2 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h2><p>尽量使用计算属性而不是watch！</p><p>可以配合着计算属性使用setter和getter</p><h2 id="绑定样式"><a href="#绑定样式" class="headerlink" title="绑定样式"></a>绑定样式</h2><ul><li>对于非行内样式<br>方法一：<br><code>:class=“{becomeRed: isActivated}”</code><br>其中isActivated放到data里面，如果是true，就有becomeRed这个class，否则就没有。</li></ul><p>方法二：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">:class=“[becomeRed]”</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">data</span>:&#123; <span class="attribute">becomeRed</span>: “”&#125;</span><br></pre></td></tr></table></figure><p>becomeRed里面放类名</p><ul><li>对于行内样式</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">:style=“styleObj”</span><br><span class="line">//或</span><br><span class="line">:style=“[styleObj,</span><br><span class="line">&#123;<span class="attribute">fontSize</span>: <span class="string">'20px'</span>&#125;]”</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">data</span>:&#123;</span><br><span class="line">    <span class="attribute">styleObj</span>:&#123;</span><br><span class="line">        color:”black”</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="v-if和v-show"><a href="#v-if和v-show" class="headerlink" title="v-if和v-show"></a>v-if和v-show</h2><p>后者只是隐藏而已，dom元素还在；前者直接杀掉dom元素。</p><p>使用后者性能更高。<br>如果要使用v-if，而且這個要隱藏的組件以後還會顯示，我們可以在這個組件標籤裡面加上一個<code>v-once</code>，以此來增加性能，不讓這個組件死掉。</p><h2 id="v-if和v-else"><a href="#v-if和v-else" class="headerlink" title="v-if和v-else"></a>v-if和v-else</h2><p>两个东西要连着写！</p><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>如果想改变数组，界面跟着变。不能使用方括号来改。<br>有三种方式：</p><ol><li>使用数组遍历函数</li><li>改变数组的引用</li><li>set方法：</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Vue.set(vm.userInfo,<span class="number">1</span>,<span class="number">5</span>)</span><br><span class="line"><span class="comment">//或</span></span><br><span class="line">vm.$<span class="keyword">set</span>(vm.userInfo,2,10)</span><br></pre></td></tr></table></figure><h2 id="template占位符"><a href="#template占位符" class="headerlink" title="template占位符"></a>template占位符</h2><p>起一个包裹的作用</p><h2 id="向对象中注入新的属性"><a href="#向对象中注入新的属性" class="headerlink" title="向对象中注入新的属性"></a>向对象中注入新的属性</h2><ol><li>改变对象的引用</li><li>set方法：</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Vue.set(vm.userInfo,”address”,”beijing”)</span><br><span class="line"><span class="comment">//或</span></span><br><span class="line">vm.$<span class="keyword">set</span>(vm.userInfo,”address”,”beijing”)</span><br></pre></td></tr></table></figure><h2 id="使用自定义组件时"><a href="#使用自定义组件时" class="headerlink" title="使用自定义组件时"></a>使用自定义组件时</h2><h3 id="is属性"><a href="#is属性" class="headerlink" title="is属性"></a>is属性</h3><p>在table、ul、select下面使用自定义标签时，使用is属性解决模板标签的bug</p><h3 id="data"><a href="#data" class="headerlink" title="data"></a>data</h3><p>不应该是个对象，而是个函数，返回content，这样的话，返回一个引用，每个子组件都可以拥有独立的数据，互不干扰。</p><h2 id="获取dom"><a href="#获取dom" class="headerlink" title="获取dom"></a>获取dom</h2><h3 id="对原生标签"><a href="#对原生标签" class="headerlink" title="对原生标签"></a>对原生标签</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ref=‘hello’</span><br><span class="line"></span><br><span class="line">this.$refs.hello</span><br></pre></td></tr></table></figure><h3 id="对自定义标签"><a href="#对自定义标签" class="headerlink" title="对自定义标签"></a>对自定义标签</h3><p>使用ref返回的是引用。</p><h2 id="父子组件的数据传递"><a href="#父子组件的数据传递" class="headerlink" title="父子组件的数据传递"></a>父子组件的数据传递</h2><h3 id="父传子"><a href="#父传子" class="headerlink" title="父传子"></a>父传子</h3><p>通过属性的形式传递数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;counter :count = &quot;0&quot;&gt;&lt;/counter&gt;//传数字</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &lt;counter count = &quot;1&quot;&gt;&lt;/counter&gt;//传字符串</span><br></pre></td></tr></table></figure><p>单向数据流：<br>父组件可以向子组件传递数据，但是子组件不能修改父组件传过来的东西。因为有可能其他组件还在使用父组件传递过来的数据，会影响其他组件。</p><p>如果要修改，得copy一份副本，修改这个副本</p><h3 id="子传父"><a href="#子传父" class="headerlink" title="子传父"></a>子传父</h3><p>激发事件emit</p><h2 id="参数校验"><a href="#参数校验" class="headerlink" title="参数校验"></a>参数校验</h2><p>props后面不写数组了，改写成一个对象，like this：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">props: &#123;</span><br><span class="line">    content: &#123;</span><br><span class="line">        type: <span class="built_in">String</span>,</span><br><span class="line">        validator: <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> (value.length &gt; <span class="number">5</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    index: <span class="built_in">Number</span>,</span><br><span class="line">    num: [<span class="built_in">String</span>,<span class="built_in">Number</span>],</span><br><span class="line">    fuck: &#123;</span><br><span class="line">        type: <span class="built_in">String</span>,</span><br><span class="line">        required: <span class="literal">false</span>,</span><br><span class="line">        <span class="keyword">default</span>: <span class="string">'default value'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="props特性"><a href="#props特性" class="headerlink" title="props特性"></a>props特性</h2><p>父组件向子组件传属性，子组件在props里面刚好声明了，即父传子接。<br>父组件和子组件有一种对应特性：</p><ol><li>这个传递属性不会在dom上显示；</li><li>子组件接受了props后，子组件就可以使用差值表达式将其显示出来。</li></ol><h2 id="非props特性"><a href="#非props特性" class="headerlink" title="非props特性"></a>非props特性</h2><p>父组件向子组件传属性，但是子组件在props里面却没有声明该属性。<br>即父传子不接。</p><ol><li>子组件没办法获取该属性的内容，因为没有获取；</li><li>非props特性会显示在dom元素里面的。</li></ol><h2 id="如何给自定义组件绑定原生事件？"><a href="#如何给自定义组件绑定原生事件？" class="headerlink" title="如何给自定义组件绑定原生事件？"></a>如何给自定义组件绑定原生事件？</h2><ul><li>方法一：</li></ul><ol><li>给子组件绑定一个原生事件，触发子组件函数；</li><li>在子组件函数里面监听，然后$emit一个自定义事件给自定义组件即可</li></ol><ul><li>方法二：<br>直接在自定义事件上面加native修饰符，这样写：<br><code>@click.native = “handleClick”</code></li></ul><h2 id="如何解决复杂的组件间传值？"><a href="#如何解决复杂的组件间传值？" class="headerlink" title="如何解决复杂的组件间传值？"></a>如何解决复杂的组件间传值？</h2><ol><li>vuex</li><li>发布订阅模式（总线机制/Bus/观察者模式）</li></ol><h3 id="总线机制"><a href="#总线机制" class="headerlink" title="总线机制"></a>总线机制</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">child</span> <span class="attr">content</span>=<span class="string">"旭凤"</span>&gt;</span><span class="tag">&lt;/<span class="name">child</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">child</span> <span class="attr">content</span>=<span class="string">"锦觅"</span>&gt;</span><span class="tag">&lt;/<span class="name">child</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">  Vue.prototype.bus = <span class="keyword">new</span> Vue();</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">  Vue.component(<span class="string">'child'</span>,&#123;</span></span><br><span class="line"><span class="javascript">    data: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> &#123;<span class="attr">selfContent</span>: <span class="keyword">this</span>.content&#125;</span></span><br><span class="line">    &#125;,</span><br><span class="line"><span class="javascript">    props: [<span class="string">'content'</span>],</span></span><br><span class="line"><span class="xml">    template: "<span class="tag">&lt;<span class="name">div</span> @<span class="attr">click</span>=<span class="string">'handleChildClick'</span>&gt;</span>&#123;&#123;selfContent&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span>",</span></span><br><span class="line">    methods: &#123;</span><br><span class="line"><span class="javascript">      handleChildClick: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">this</span>.bus.$emit(<span class="string">'change'</span>, <span class="keyword">this</span>.selfContent);</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line"><span class="javascript">    mounted: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">var</span> that = <span class="keyword">this</span>;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">this</span>.bus.$on(<span class="string">'change'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">msg</span>) </span>&#123;</span></span><br><span class="line">        that.selfContent = msg;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    el: <span class="string">'#app'</span></span></span><br><span class="line">  &#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="插槽"><a href="#插槽" class="headerlink" title="插槽"></a>插槽</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;slot&gt;默认内容&lt;/slot&gt;</span><br></pre></td></tr></table></figure><h3 id="具名插槽"><a href="#具名插槽" class="headerlink" title="具名插槽"></a>具名插槽</h3><p>给插槽起一个名字，插到指定的位置</p><h3 id="作用域插槽"><a href="#作用域插槽" class="headerlink" title="作用域插槽"></a>作用域插槽</h3><p>当子组件做循环或某一部分它的dom结构应该由外部传进来的时候，使用作用域插槽。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">sweet</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">template</span> <span class="attr">slot-scope</span>=<span class="string">'props'</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;&#123;props.item&#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">sweet</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">    Vue.component(<span class="string">'sweet'</span>,&#123;</span></span><br><span class="line"><span class="javascript">      data: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="javascript">          list: [<span class="string">'錦覓'</span>, <span class="string">'旭鳳'</span>, <span class="string">'潤玉'</span>]</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      template:</span><br><span class="line"><span class="xml">      `<span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line">          &lt;slot</span><br><span class="line"><span class="javascript">            v-<span class="keyword">for</span>=<span class="string">'item in list'</span></span></span><br><span class="line"><span class="javascript">            :item=<span class="string">'item'</span></span></span><br><span class="line"><span class="javascript">          &gt;<span class="xml"><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span>`</span></span><br><span class="line">    &#125;)</span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">      el: <span class="string">'#app'</span></span></span><br><span class="line">    &#125;);</span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="動態組件"><a href="#動態組件" class="headerlink" title="動態組件"></a>動態組件</h2><p><code>&lt;component :is=“type”&gt;&lt;/component&gt;</code><br>這個type是根實例data裡面的一個屬性，用於替換component變成你自定義過的自定義組件。</p><p>可以用於替代v-if的效果！</p><hr><h2 id="動畫"><a href="#動畫" class="headerlink" title="動畫"></a>動畫</h2><p>过渡动态效果</p><h3 id="渐入"><a href="#渐入" class="headerlink" title="渐入"></a>渐入</h3><img src="https://i.loli.net/2018/09/06/5b9144610c7e9.jpg" srcset="/img/loading.gif"><h3 id="渐出"><a href="#渐出" class="headerlink" title="渐出"></a>渐出</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">transition</span> <span class="attr">name</span>=<span class="string">'fade'</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-show</span>=<span class="string">'seen'</span>&gt;</span>香蜜沉沉烬如霜<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">transition</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"button"</span> @<span class="attr">click</span>=<span class="string">'handleBtnClick'</span>&gt;</span>change<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">    <span class="selector-class">.fade-enter</span>, <span class="selector-class">.fade-leave-to</span>&#123;</span></span><br><span class="line">      opacity: 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">    <span class="selector-class">.fade-enter-active</span>, <span class="selector-class">.fade-leave-active</span>&#123;</span></span><br><span class="line">      transition: opacity 3s;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="Animate-css"><a href="#Animate-css" class="headerlink" title="Animate.css"></a>Animate.css</h3><ul><li>keyframes自定义的标签动画</li><li>导入animate库</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">transition</span></span></span><br><span class="line"><span class="tag">         <span class="attr">name</span>=<span class="string">"fade"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">enter-active-class</span>=<span class="string">"animated swing"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">leave-active-class</span>=<span class="string">"animated shake"</span></span></span><br><span class="line"><span class="tag">      &gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-show</span>=<span class="string">'seen'</span>&gt;</span>香蜜沉沉烬如霜<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">transition</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="如何让刷新之后自动显示动画？"><a href="#如何让刷新之后自动显示动画？" class="headerlink" title="如何让刷新之后自动显示动画？"></a>如何让刷新之后自动显示动画？</h4><p>在transition标签里面加上这么两个属性：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">appear</span><br><span class="line"></span><br><span class="line">appear-active-<span class="class"><span class="keyword">class</span></span>=“animated swing”</span><br></pre></td></tr></table></figure><h4 id="如何让keyframes动画和transiton动画融合在一起？"><a href="#如何让keyframes动画和transiton动画融合在一起？" class="headerlink" title="如何让keyframes动画和transiton动画融合在一起？"></a>如何让keyframes动画和transiton动画融合在一起？</h4><p>都放到enter和leave的那两个active class里面去。</p><h4 id="两者时间不统一，如何设定动画时间？"><a href="#两者时间不统一，如何设定动画时间？" class="headerlink" title="两者时间不统一，如何设定动画时间？"></a>两者时间不统一，如何设定动画时间？</h4><p>在transition标签里面加上这么几条属性即可：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">:duration=“&#123;<span class="attr">enter</span>: <span class="number">5000</span>, <span class="attr">leave</span>: <span class="number">10000</span>&#125;”</span><br><span class="line"></span><br><span class="line"><span class="comment">//或</span></span><br><span class="line">:duration=<span class="string">"1000"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//或</span></span><br><span class="line">type=<span class="string">"transition"</span></span><br></pre></td></tr></table></figure><h3 id="js动画"><a href="#js动画" class="headerlink" title="js动画"></a>js动画</h3><p>使用js动画钩子。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&lt;transition</span><br><span class="line">         name=&quot;fade&quot;</span><br><span class="line">         @before-enter=&quot;handleBeforeEnter&quot;</span><br><span class="line">         @enter=&quot;handleEnter&quot;</span><br><span class="line">         @after-enter=&quot;handleAfterEnter&quot;</span><br><span class="line">      &gt;</span><br><span class="line">        &lt;div v-show=&apos;seen&apos;&gt;香蜜沉沉烬如霜&lt;/div&gt;</span><br><span class="line">      &lt;/transition&gt;</span><br><span class="line"></span><br><span class="line">methods: &#123;</span><br><span class="line">          handleBtnClick: function() &#123;</span><br><span class="line">            this.seen = !this.seen</span><br><span class="line">          &#125;,</span><br><span class="line">          handleBeforeEnter: function(el) &#123;</span><br><span class="line">            el.style.color = &apos;pink&apos;;</span><br><span class="line">          &#125;,</span><br><span class="line">          handleEnter: function(el, done) &#123;</span><br><span class="line">            setTimeout(()=&gt;&#123;</span><br><span class="line">              el.style.color = &apos;blue&apos;</span><br><span class="line">            &#125;,2000);</span><br><span class="line">            setTimeout(()=&gt;&#123;</span><br><span class="line">              done()</span><br><span class="line">            &#125;,4000);</span><br><span class="line">          &#125;,</span><br><span class="line">          handleAfterEnter: function(el) &#123;</span><br><span class="line">            el.style.color = &apos;red&apos;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h3 id="使用velocity-js来创作js动画"><a href="#使用velocity-js来创作js动画" class="headerlink" title="使用velocity.js来创作js动画"></a>使用velocity.js来创作js动画</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">methods: &#123;</span><br><span class="line">        handleBtnClick: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">          <span class="keyword">this</span>.seen = !<span class="keyword">this</span>.seen</span><br><span class="line">        &#125;,</span><br><span class="line">        handleBeforeEnter: <span class="function"><span class="keyword">function</span>(<span class="params">el</span>) </span>&#123;</span><br><span class="line">          el.style.opacity = <span class="number">0</span>;</span><br><span class="line">        &#125;,</span><br><span class="line">        handleEnter: <span class="function"><span class="keyword">function</span>(<span class="params">el, done</span>) </span>&#123;</span><br><span class="line">          Velocity(el,&#123;</span><br><span class="line">            opacity: <span class="number">1</span></span><br><span class="line">          &#125;,&#123;</span><br><span class="line">            duration: <span class="number">1000</span>,</span><br><span class="line">            complete: done</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;,</span><br><span class="line">        handleAfterEnter: <span class="function"><span class="keyword">function</span>(<span class="params">el</span>) </span>&#123;</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="string">'4s是垃圾！'</span>)</span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        handleBeforeLeave: <span class="function"><span class="keyword">function</span>(<span class="params">el</span>) </span>&#123;</span><br><span class="line">          el.style.opacity = <span class="number">1</span>;</span><br><span class="line">        &#125;,</span><br><span class="line">        handleLeave: <span class="function"><span class="keyword">function</span>(<span class="params">el, done</span>) </span>&#123;</span><br><span class="line">          Velocity(el,&#123;</span><br><span class="line">            opacity: <span class="number">0</span></span><br><span class="line">          &#125;,&#123;</span><br><span class="line">            duration: <span class="number">1000</span>,</span><br><span class="line">            complete: done</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;,</span><br><span class="line">        handleAfterLeave: <span class="function"><span class="keyword">function</span>(<span class="params">el</span>) </span>&#123;</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="string">'我走了！'</span>)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><h3 id="多元素过渡效果"><a href="#多元素过渡效果" class="headerlink" title="多元素过渡效果"></a>多元素过渡效果</h3><ul><li>對原生組件</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="selector-tag">style</span>&gt;</span><br><span class="line">      <span class="selector-class">.fade-enter</span>, <span class="selector-class">.fade-leave-to</span> &#123;</span><br><span class="line">        <span class="attribute">opacity</span>: <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="selector-class">.fade-enter-active</span>, <span class="selector-class">.fade-leave-active</span> &#123;</span><br><span class="line">        <span class="attribute">transition</span>: opacity <span class="number">1s</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  &lt;<span class="selector-tag">transition</span></span><br><span class="line">         name="fade"</span><br><span class="line">         mode="out-in"</span><br><span class="line">      &gt;</span><br><span class="line">        &lt;div v-if='seen' key='flower'&gt;錦覓&lt;/div&gt;</span><br><span class="line">        &lt;div v-else key='bird'&gt;旭鳳&lt;/div&gt;</span><br><span class="line">      &lt;/transition&gt;</span><br></pre></td></tr></table></figure><ul><li>對自定義組件</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;child v-if=“show”&gt;&lt;/child&gt;</span><br><span class="line">&lt;child-one v-else&gt;&lt;/child-one&gt;</span><br></pre></td></tr></table></figure><ul><li>對動態組件<br>直接用component標籤替換這兩child，就可以直接使用。效果一樣哦。</li></ul><h3 id="列表過渡"><a href="#列表過渡" class="headerlink" title="列表過渡"></a>列表過渡</h3><p>使用transition-group標籤代替transition標籤，來包裹列表，其他部分使用起來和前面一樣。</p><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>相當於在每一個表項div外面包裹了一個transition標籤，對它使用一些如v-enter的class。</p><h3 id="動畫封裝"><a href="#動畫封裝" class="headerlink" title="動畫封裝"></a>動畫封裝</h3><p>不用css動畫了，用js動畫。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;实例-vue是由实例组成的&quot;&gt;&lt;a href=&quot;#实例-vue是由实例组成的&quot; class=&quot;headerlink&quot; title=&quot;实例-vue是由实例组成的&quot;&gt;&lt;/a&gt;实例-vue是由实例组成的&lt;/h2&gt;&lt;p&gt;根实例&lt;br&gt;组件也是实例&lt;/p&gt;
&lt;p&gt;以$开头的
      
    
    </summary>
    
    
      <category term="vue" scheme="https://wy200088.github.io/categories/vue/"/>
    
    
      <category term="vue基础" scheme="https://wy200088.github.io/tags/vue%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>给博客加入B站视频</title>
    <link href="https://wy200088.github.io/2019/11/06/%E7%BB%99%E5%8D%9A%E5%AE%A2%E5%8A%A0%E5%85%A5B%E7%AB%99%E8%A7%86%E9%A2%91/"/>
    <id>https://wy200088.github.io/2019/11/06/给博客加入B站视频/</id>
    <published>2019-11-06T02:43:39.000Z</published>
    <updated>2019-11-06T03:05:02.662Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="Hexo博客插入bilibili视频"><a href="#Hexo博客插入bilibili视频" class="headerlink" title="Hexo博客插入bilibili视频"></a>Hexo博客插入bilibili视频</h1><h4 id="一、选择自己喜欢的视频"><a href="#一、选择自己喜欢的视频" class="headerlink" title="一、选择自己喜欢的视频"></a>一、选择自己喜欢的视频</h4><p>首先代开哔哩哔哩官网，然后去找自己想要加入的视频，打开那个视频，将鼠标移动到分享按钮然后会出现视频播放器的html代码。</p><img src="https://ss1.baidu.com/6ONXsjip0QIZ8tyhnq/it/u=4242498199,1328953498&fm=173&app=49&f=JPEG?w=640&h=368&s=4208F9021687B8AFA717055E030010E2" srcset="/img/loading.gif"><p>将其复制下来。</p><h4 id="二、在想要的地方插入视频外链"><a href="#二、在想要的地方插入视频外链" class="headerlink" title="二、在想要的地方插入视频外链"></a>二、在想要的地方插入视频外链</h4><p>我们知道在md中可以直接插入html代码，所以直接找到自己想要插入的界面找到相对应的文件，将代码拷贝进去即可，不过直接复制过来的代码拷贝进去的效果是自适应的一个状态，无法快进无法全屏十分不舒服。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">"视频链接"</span> <span class="attr">scrolling</span>=<span class="string">"no"</span> <span class="attr">border</span>=<span class="string">"0"</span> <span class="attr">frameborder</span>=<span class="string">"no"</span> <span class="attr">framespacing</span>=<span class="string">"0"</span> <span class="attr">allowfullscreen</span>=<span class="string">"true"</span>&gt;</span> <span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br></pre></td></tr></table></figure><p>将其修改一下src内的内容，于是又改了改播放器的样式给他加上了宽高等。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">"视频链接"</span> <span class="attr">width</span>=<span class="string">"780"</span> <span class="attr">height</span>=<span class="string">"480"</span> <span class="attr">scrolling</span>=<span class="string">"no"</span> <span class="attr">border</span>=<span class="string">"0"</span> <span class="attr">frameborder</span>=<span class="string">"no"</span> <span class="attr">framespacing</span>=<span class="string">"0"</span> <span class="attr">allowfullscreen</span>=<span class="string">"true"</span>&gt;</span> <span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br></pre></td></tr></table></figure><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/bilibili2.png" srcset="/img/loading.gif"><p>但是在手机上会变成这个亚子，还是会有一些不足。</p><p>然后博主又在网上找了很多解决这个的办法，最终找到一个还不错的处理方法。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"position: relative; width: 100%; height: 0; padding-bottom: 75%;"</span>&gt;</span><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">"视频链接"</span> <span class="attr">scrolling</span>=<span class="string">"no"</span> <span class="attr">border</span>=<span class="string">"0"</span> <span class="attr">frameborder</span>=<span class="string">"no"</span> <span class="attr">framespacing</span>=<span class="string">"0"</span> <span class="attr">allowfullscreen</span>=<span class="string">"true"</span> <span class="attr">style</span>=<span class="string">"position: absolute; width: 100%; height: 100%; left: 0; top: 0;"</span>&gt;</span> <span class="tag">&lt;/<span class="name">iframe</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><img src="https://teamssix.oss-cn-hangzhou.aliyuncs.com/bilibili3.png" srcset="/img/loading.gif"><p>不过这还是有缺陷的，在手机端不可以全屏，还是有些美中不足，所以只好也将视频播放链接放到视频下面了，如果不能全屏就只能去源链接去看了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;h1 id=&quot;Hexo博客插入bilibili视频&quot;&gt;&lt;a href=&quot;#Hexo博客插入bilibili视频&quot; class=&quot;headerlink&quot; title=&quot;Hexo博客插入bi
      
    
    </summary>
    
    
      <category term="Hexo博客" scheme="https://wy200088.github.io/categories/Hexo%E5%8D%9A%E5%AE%A2/"/>
    
    
      <category term="Hexo添加bilibili视频" scheme="https://wy200088.github.io/tags/Hexo%E6%B7%BB%E5%8A%A0bilibili%E8%A7%86%E9%A2%91/"/>
    
  </entry>
  
  <entry>
    <title>给博客插入网易云音乐</title>
    <link href="https://wy200088.github.io/2019/11/06/%E7%BB%99%E5%8D%9A%E5%AE%A2%E6%8F%92%E5%85%A5%E7%BD%91%E6%98%93%E4%BA%91%E9%9F%B3%E4%B9%90/"/>
    <id>https://wy200088.github.io/2019/11/06/给博客插入网易云音乐/</id>
    <published>2019-11-06T02:01:30.000Z</published>
    <updated>2019-11-06T02:24:36.133Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="Hexo博客插入网易云音乐"><a href="#Hexo博客插入网易云音乐" class="headerlink" title="Hexo博客插入网易云音乐"></a>Hexo博客插入网易云音乐</h1><h4 id="一、选择自己喜欢的音乐"><a href="#一、选择自己喜欢的音乐" class="headerlink" title="一、选择自己喜欢的音乐"></a>一、选择自己喜欢的音乐</h4><p>  首先你要先去网易云音乐的官网寻找自己喜欢的音乐，不过有些音乐是有版权的有些音乐是没有版权的，有版权的可以生成外联播放器，没有版权的则是不能生成的，所以第一步要选好自己喜欢的音乐也是看清楚自己喜欢的音乐有没有版权。</p><img src="https://img2018.cnblogs.com/blog/1242355/201903/1242355-20190302164911990-1606880343.png" srcset="/img/loading.gif"><p>可以生成的话就会出现这个东西~</p><img src="https://img2018.cnblogs.com/blog/1242355/201903/1242355-20190302165443246-736866412.png" srcset="/img/loading.gif"><h4 id="二、添加到博客中"><a href="#二、添加到博客中" class="headerlink" title="二、添加到博客中"></a>二、添加到博客中</h4><p>  在上一步中我们已经获取到网易云音乐插件的HTML代码，然后我们就可以找到需要加入音乐的页面插入这个代码。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"music163player"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">iframe</span> <span class="attr">frameborder</span>=<span class="string">"no"</span> <span class="attr">border</span>=<span class="string">"0"</span> <span class="attr">marginwidth</span>=<span class="string">"0"</span> <span class="attr">marginheight</span>=<span class="string">"0"</span> <span class="attr">width</span>=<span class="string">280</span> <span class="attr">height</span>=<span class="string">86</span> <span class="attr">src</span>=<span class="string">"//music.163.com/outchain/player?type=2&amp;id=33911781&amp;auto=1&amp;height=66"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>当然你还可以用<font color="#blue" face="微软雅黑">CSS position属性</font>进行定位，可以说是想放到页面的哪里就放到哪里。</p><p><font color="#00BFFF" face="微软雅黑" size="3">好了添加网易云音乐插件很简单，其实就是将代码插入你想要个页面的html代码里就好了，主题不同可能你需要插入到的文件也不同，所以在插入的时候自己一定要搞明白自己的主题哪个文件是哪个界面，拜拜~</font></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;h1 id=&quot;Hexo博客插入网易云音乐&quot;&gt;&lt;a href=&quot;#Hexo博客插入网易云音乐&quot; class=&quot;headerlink&quot; title=&quot;Hexo博客插入网易云音乐&quot;&gt;&lt;/a&gt;H
      
    
    </summary>
    
    
      <category term="Hexo博客" scheme="https://wy200088.github.io/categories/Hexo%E5%8D%9A%E5%AE%A2/"/>
    
    
      <category term="Hexo添加音乐" scheme="https://wy200088.github.io/tags/Hexo%E6%B7%BB%E5%8A%A0%E9%9F%B3%E4%B9%90/"/>
    
  </entry>
  
  <entry>
    <title>JAVA对象内存图分析与详解</title>
    <link href="https://wy200088.github.io/2019/11/04/JAVA%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E5%9B%BE%E5%88%86%E6%9E%90%E4%B8%8E%E8%AF%A6%E8%A7%A3/"/>
    <id>https://wy200088.github.io/2019/11/04/JAVA对象内存图分析与详解/</id>
    <published>2019-11-04T08:40:46.000Z</published>
    <updated>2019-11-14T07:52:01.663Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"># JAVA对象内存图分析与详解<p>讲Java对象内存图之前先了解一下以下几个概念：</p><img src="https://pics1.baidu.com/feed/3b87e950352ac65c76b3670fdcc12d1592138acb.jpeg?token=1f617463a65d85332a757b8a7f1e4c73&s=B1B667364503534314FA8B7C03006073" srcset="/img/loading.gif"><p><font color="#100101" size="4" face="微软雅黑"><strong>堆区</strong></font>：1.存储new出来的对象，每个对象都包含一个与之对应的class的信息。(class的目的是得到操作指令) 2.jvm只有一个堆区(heap)被所有线程共享，堆中不存放基本类型和对象引用，只存放对象本身 。</p><p><font color="#100101" size="4" face="微软雅黑"><strong>栈区</strong></font>：1.每个线程包含一个栈区，栈中只保存基础数据类型的值和对象以及基础数据的引用。2.每个栈中的数据(基础数据类型和对象引用)都是私有的，其他栈不能访问。 3.栈分为3个部分：基本类型变量区、执行环境上下文、操作指令区(存放操作指令)</p><p><font color="#100101" size="4" face="微软雅黑"><strong>·方法区</strong></font>：1.又叫静态区，跟堆一样，被所有的线程共享。方法区包含所有的class和static变量。 2.方法区中包含的都是在整个程序中永远唯一的元素，如class，static变量。</p><img src="https://pics0.baidu.com/feed/43a7d933c895d1436cb3b5a454c31d065baf0723.jpeg?token=162e17b0860800abcd017f033e2da284&s=ABA07922B3C66D5B0EF1F0CB000010B1" srcset="/img/loading.gif"><h2 id="对象内存图"><a href="#对象内存图" class="headerlink" title="对象内存图"></a>对象内存图</h2><h4 id="1、一个对象调用一个方法内存图"><a href="#1、一个对象调用一个方法内存图" class="headerlink" title="1、一个对象调用一个方法内存图"></a>1、一个对象调用一个方法内存图</h4><img src="https://pics1.baidu.com/feed/9d82d158ccbf6c817327e9e4940d2e3133fa4066.jpeg?token=aafed1f8ffc3b95abfa802f63bb5e90f&s=CC9AE912A7C4595B404129CE0200C0B2" srcset="/img/loading.gif"><p>首先JVM运行一个class文件时，使用类加载器先将Demo类加载到方法区，然后main方法压栈（入栈）。</p><p>在栈中运行main方法，当jvm看到Phone时，会自动把Phone类加载到方法区；当看到局部变量p时，会在栈中开辟一块空间；当看到new Phone（）时，会在堆内存中开辟空间，并将堆内存中的对应地址0x123赋值给p;还会拿到方法区的地址值指向方法区。</p><p>·在main方法中运行到给对象p的属性赋值时，通过地址去堆内存中找到相应属性并赋值，运行p.sendMessage（）这一步时，也是根据地址值去堆内存中找到相应的对象，再用对象去方法区中找到sendMessage（）方法，然后将sendMessage（）方法压到栈中（入栈），调用完毕sendMessage（）方法会出栈。</p><p>·main方法运行结束后会出栈。</p><p>通过以上步骤描述，我们可以理解，在栈内存中运行的方法，遵循”先进后出，后进先出”的原则。变量p指向堆内存中的空间，寻找方法信息，去执行该方法。</p><h4 id="2、两个对象调用同一个方法内存图"><a href="#2、两个对象调用同一个方法内存图" class="headerlink" title="2、两个对象调用同一个方法内存图"></a>2、两个对象调用同一个方法内存图</h4><img src="https://pics2.baidu.com/feed/a8ec8a13632762d081a87eae88df97fe503dc6c1.jpeg?token=6829c84bf7a4de1d534b752b776f5de7&s=0C90C8139781494B005148C3030030B2" srcset="/img/loading.gif"><p>对象调用方法时，根据对象中方法标记（地址值），去类中寻找方法信息。这样哪怕是多个对象，方法信息只保存一份，节约内存空间。</p><h4 id="3、一个引用，作为参数传递到方法中内存图"><a href="#3、一个引用，作为参数传递到方法中内存图" class="headerlink" title="3、一个引用，作为参数传递到方法中内存图"></a>3、一个引用，作为参数传递到方法中内存图</h4><img src="https://pics4.baidu.com/feed/2e2eb9389b504fc29177feccc2ee781591ef6d82.jpeg?token=45a66ec47b4da4705703d5a039be2ee4&s=CCC2FD1295C0594B00E1E1CF030080B2" srcset="/img/loading.gif"><p>引用类型作为参数，传递的是地址值。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;
# JAVA对象内存图分析与详解

&lt;p&gt;讲Java对象内存图之前先了解一下以下几个概念：&lt;/p&gt;
&lt;img src=&quot;https://pics1.baidu.com/feed/3b87e9
      
    
    </summary>
    
    
      <category term="JAVA" scheme="https://wy200088.github.io/categories/JAVA/"/>
    
    
      <category term="JAVA内存" scheme="https://wy200088.github.io/tags/JAVA%E5%86%85%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>JSP九大内置对象</title>
    <link href="https://wy200088.github.io/2019/10/31/JSP%E4%B9%9D%E5%A4%A7%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1/"/>
    <id>https://wy200088.github.io/2019/10/31/JSP九大内置对象/</id>
    <published>2019-10-31T00:02:01.000Z</published>
    <updated>2019-11-14T07:53:19.623Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JSP九大内置对象"><a href="#JSP九大内置对象" class="headerlink" title="JSP九大内置对象"></a>JSP九大内置对象</h2><h4 id="1-request对象"><a href="#1-request对象" class="headerlink" title="1.request对象"></a>1.request对象</h4><p>​    客户端的请求信息被封装在request对象中，通过它才能了解到客户的需求，然后做出响应。它是HttpServletRequest类的实例。</p><p>​    <code>序号方 法说 明1 object getAttribute(String name)返回指定属性的属性值2 Enumeration getAttributeNames()返回所有可用属性名的枚举3 String getCharacterEncoding()返回字符编码方式4 int getContentLength()返回请求体的长度（以字节数）5 String getContentType()得到请求体的MIME类型6 ServletInputStream getInputStream()得到请求体中一行的二进制流7 String getParameter(String name)返回name指定参数的参数值8 Enumeration getParameterNames()返回可用参数名的枚举9 String[] getParameterValues(String name)返回包含参数name的所有值的数组10 String getProtocol()返回请求用的协议类型及版本号11 String getScheme()返回请求用的计划名,如:http.https及ftp等12 String getServerName()返回接受请求的服务器主机名13 int getServerPort()返回服务器接受此请求所用的端口号14 BufferedReader getReader()返回解码过了的请求体15 String getRemoteAddr()返回发送此请求的客户端IP地址16 String getRemoteHost()返回发送此请求的客户端主机名17 void setAttribute(String key,Object obj)设置属性的属性值18 String getRealPath(String path)返回一虚拟路径的真实路径</code>.</p><p><code>&lt;%@ page contentType=&quot;text/html;charset=gb2312&quot;%&gt;</code><br><code>&lt;%request.setCharacterEncoding(&quot;gb2312&quot;);%&gt;</code><br><code>&lt;html&gt;</code></p><head><meta name="generator" content="Hexo 3.9.0"><title>request对象_例1</title></head>`<body bgcolor="#FFFFF0">`<form action method="post">  <input type="text" name="qwe">  <input type="submit" value="提交"></form>`请求方式：<%=request.getmethod()%><br>``请求的资源：<%=request.getrequesturi()%><br>``请求用的协议：<%=request.getprotocol()%><br>``请求的文件名：<%=request.getservletpath()%><br>``请求的服务器的IP：<%=request.getservername()%><br>``请求服务器的端口：<%=request.getserverport()%><br>``客户端IP地址：<%=request.getremoteaddr()%><br>``客户端主机名：<%=request.getremotehost()%><br>``表单提交来的值：<%=request.getparameter("qwe")%><br>``</%=request.getparameter("qwe")%></%=request.getremotehost()%></%=request.getremoteaddr()%></%=request.getserverport()%></%=request.getservername()%></%=request.getservletpath()%></%=request.getprotocol()%></%=request.getrequesturi()%></%=request.getmethod()%></body>```<p><code>&lt;%@ page contentType=&quot;text/html;charset=gb2312&quot;%&gt;</code><br><code>&lt;%request.setCharacterEncoding(&quot;gb2312&quot;);%&gt;</code><br><code>&lt;%@ page import=&quot;java.util.Enumeration&quot;%&gt;</code><br><code>&lt;html&gt;</code></p><head><meta name="generator" content="Hexo 3.9.0">  <title>request对象_例2</title></head>`<body bgcolor="#FFFFF0">`<form action method="post">   用户名：<input type="text" name="username">&nbsp;&nbsp;   密 码：<input type="text" name="userpass">&nbsp;&nbsp;   <input type="submit" value="进入"></form>`<%` `string str ;` `if(request.getparameter("username")!="null" && request.getparameter("userpass")!="null){`" `enumeration enumt="request.getParameterNames();`" `while(enumt.hasmoreelements()){` `str="enumt.nextElement().toString();`" `out.println(str+":"+request.getparameter(str)+"<br>");`   `}``}``%>``</%`></body>```<p><code>&lt;%@ page contentType=&quot;text/html;charset=gb2312&quot;%&gt;</code><br><code>&lt;%request.setCharacterEncoding(&quot;gb2312&quot;);%&gt;</code><br><code>&lt;html&gt;</code></p><head><meta name="generator" content="Hexo 3.9.0">   <title>request对象_例3</title></head>`<body bgcolor="#FFFFF0">`<form action method="post">  擅长：<input type="checkbox" name="cb" value="ON1">VC++&nbsp;       <input type="checkbox" name="cb" value="ON2">JAVA&nbsp;       <input type="checkbox" name="cb" value="ON3">DELPHI&nbsp;       <input type="checkbox" name="cb" value="ON4">VB&nbsp;       <br>       <input type="submit" value="进入" name="qwe"></form>`<%` `if(request.getparameter("qwe")!="null" ){` `for(int i="0;i<request.getParameterValues(" cb").length;i++){`" `out.println("cb"+i+":"+request.getparametervalues("cb")[i]+"<br>");`   `}`   `out.println(request.getParameter("qwe"));``}``%>``</%`></body>```<h4 id="2-response对象"><a href="#2-response对象" class="headerlink" title="2.response对象"></a>2.response对象</h4><p>​    response对象包含了响应客户请求的有关信息，但在JSP中很少直接用到它。它是HttpServletResponse类的实例。</p><p>​    <code>序号方 法说 明1 String getCharacterEncoding()返回响应用的是何种字符编码2 ServletOutputStream getOutputStream()返回响应的一个二进制输出流3 PrintWriter getWriter()返回可以向客户端输出字符的一个对象4 void setContentLength(int len)设置响应头长度5 void setContentType(String type)设置响应的MIME类型6 sendRedirect(java.lang.String location)重新定向客户端的请求</code>.</p><h4 id="3-session对象"><a href="#3-session对象" class="headerlink" title="3.session对象"></a>3.session对象</h4><p>​    session对象指的是客户端与服务器的一次会话，从客户连到服务器的一个WebApplication开始，直到客户端与服务器断开连接为止。它是HttpSession类的实例.</p><p>​    <code>序号方 法说 明1 long getCreationTime()返回SESSION创建时间2 public String getId()返回SESSION创建时JSP引擎为它设的惟一ID号3 long getLastAccessedTime()返回此SESSION里客户端最近一次请求时间4 int getMaxInactiveInterval()返回两次请求间隔多长时间此SESSION被取消(ms)5 String[] getValueNames()返回一个包含此SESSION中所有可用属性的数组6 void invalidate()取消SESSION，使SESSION不可用7 boolean isNew()返回服务器创建的一个SESSION,客户端是否已经加入8 void removeValue(String name)删除SESSION中指定的属性9 void setMaxInactiveInterval()设置两次请求间隔多长时间此SESSION被取消(ms)</code></p><p>`&lt;%@ page contentType=”text/html;charset=gb2312”%&gt;<br>&lt;%@ page import=”java.util.*” %&gt;</p><html>`<head><meta name="generator" content="Hexo 3.9.0"><title>session对象_例1</title><head><meta name="generator" content="Hexo 3.9.0"></head></head><body><br>   session的创建时间:<%=session.getcreationtime()%>&nbsp;&nbsp;<%=new date(session.getcreationtime())%><br><br>   session的Id号:<%=session.getid()%><br><br>   客户端最近一次请求时间:<%=session.getlastaccessedtime()%>&nbsp;&nbsp;<%=new java.sql. time(session.getlastaccessedtime())%><br><br>   两次请求间隔多长时间此SESSION被取消(ms):<%=session.getmaxinactiveinterval()%><br><br>   是否是新创建的一个SESSION:<%=session.isnew()?"是":"否"%><br><br><% session.putvalue("name","霖苑编程"); session.putvalue("nmber","147369"); %><% for(int i="0;i<session.getValueNames().length;i++)" out.println(session.getvaluenames()[i]+"="+session.getValue(session.getValueNames()[i]));%><!--返回的是从格林威治时间(GMT)1970年01月01日0：00：00起到计算当时的毫秒数--></body></html><h4 id=" 4-out对象"><a href="#4-out对象" class="headerlink" title="4.out对象"></a>4.out对象<p>​    out对象是JspWriter类的实例,是向客户端输出内容常用的对象</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">序号方 法说 明<span class="number">1</span> <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span>清除缓冲区的内容2 <span class="keyword">void</span> <span class="title">clearBuffer</span><span class="params">()</span>清除缓冲区的当前内容3 <span class="keyword">void</span> <span class="title">flush</span><span class="params">()</span>清空流4 <span class="keyword">int</span> <span class="title">getBufferSize</span><span class="params">()</span>返回缓冲区以字节数的大小，如不设缓冲区则为05 <span class="keyword">int</span> <span class="title">getRemaining</span><span class="params">()</span>返回缓冲区还剩余多少可用6 <span class="keyword">boolean</span> <span class="title">isAutoFlush</span><span class="params">()</span>返回缓冲区满时，是自动清空还是抛出异常7 <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span>关闭输出流</span></span><br></pre></td></tr></table></figure><p><code>&lt;%@page contentType=&quot;text/html;charset=gb2312&quot;%&gt;</code><br><code>&lt;html&gt;&lt;head&gt;&lt;title&gt;out对象_例1:缓存测试&lt;/title&gt;&lt;/head&gt;</code><br><code>&lt;%@page buffer=&quot;1kb&quot;%&gt;</code><br><code>&lt;body&gt;</code><br><code>&lt;%</code><br>  <code>for(int i=0;i&lt;2000;i++)</code><br>  <code>out.println(i+&quot;{&quot;+out.getRemaining()+&quot;}&quot;);</code><br><code>%&gt;&lt;br&gt;</code><br><code>缓存大小：&lt;%=out.getBufferSize()%&gt;&lt;br&gt;</code><br><code>剩余缓存大小：&lt;%=out.getRemaining()%&gt;&lt;br&gt;</code><br><code>自动刷新：&lt;%=out.isAutoFlush()%&gt;&lt;br&gt;</code><br><code>&lt;%--out.clearBuffer();--%&gt;</code><br><code>&lt;%--out.clear();--%&gt;</code><br><code>&lt;!--缺省情况下:服务端要输出到客户端的内容,不直接写到客户端,而是先写到一个输出缓冲区中.只有在下面三中情况下，才会把该缓冲区的内容输出到客户端上： 1.该JSP网页已完成信息的输出 2.输出缓冲区已满 3.JSP中调用了out.flush()或response.flushbuffer() --&gt;</code><br><code>&lt;/body&gt;</code><br><code>&lt;/html&gt;</code></p><h4 id="5-page对象"><a href="#5-page对象" class="headerlink" title="5.page对象"></a>5.page对象</h4><p>​    page对象就是指向当前JSP页面本身，有点象类中的this指针，它是java.lang.Object类的实例</p><p>​    <code>序号方 法说 明1 class getClass返回此Object的类2 int hashCode()返回此Object的hash码3 boolean equals(Object obj)判断此Object是否与指定的Object对象相等4 void copy(Object obj)把此Object拷贝到指定的Object对象中5 Object clone()克隆此Object对象6 String toString()把此Object对象转换成String类的对象7 void notify()唤醒一个等待的线程8 void notifyAll()唤醒所有等待的线程9 void wait(int timeout)使一个线程处于等待直到timeout结束或被唤醒10 void wait()使一个线程处于等待直到被唤醒11 void enterMonitor()对Object加锁12 void exitMonitor()对Object开锁</code></p><h4 id="6-application对象"><a href="#6-application对象" class="headerlink" title="6.application对象"></a>6.application对象</h4><p>​    application对象实现了用户间数据的共享，可存放全局变量。它开始于服务器的启动，直到服务器的关闭，在此期间，此对象将一直存在；这样在用户的前后连接或不同用户之间的连接中，可以对此对象的同一属性进行操作；在任何地方对此对象属性的操作，都将影响到其他用户对此的访问。服务器的启动和关闭决定了application对象的生命。它是ServletContext类的实例。</p><p>​    <code>序号方 法说 明1 Object getAttribute(String name)返回给定名的属性值2 Enumeration getAttributeNames()返回所有可用属性名的枚举3 void setAttribute(String name,Object obj)设定属性的属性值4 void removeAttribute(String name)删除一属性及其属性值5 String getServerInfo()返回JSP(SERVLET)引擎名及版本号6 String getRealPath(String path)返回一虚拟路径的真实路径7 ServletContext getContext(String uripath)返回指定WebApplication的application对象8 int getMajorVersion()返回服务器支持的Servlet API的最大版本号9 int getMinorVersion()返回服务器支持的Servlet API的最大版本号10 String getMimeType(String file)返回指定文件的MIME类型11 URL getResource(String path)返回指定资源(文件及目录)的URL路径12 InputStream getResourceAsStream(String path)返回指定资源的输入流13 RequestDispatcher getRequestDispatcher(String uripath)返回指定资源的RequestDispatcher对象14 Servlet getServlet(String name)返回指定名的Servlet15 Enumeration getServlets()返回所有Servlet的枚举16 Enumeration getServletNames()返回所有Servlet名的枚举17 void log(String msg)把指定消息写入Servlet的日志文件18 void log(Exception exception,String msg)把指定异常的栈轨迹及错误消息写入Servlet的日志文件19 void log(String msg,Throwable throwable)把栈轨迹及给出的Throwable异常的说明信息 写入Servlet的日志文件</code>.</p><p><code>&lt;%@ page contentType=&quot;text/html;charset=gb2312&quot;%&gt;</code><br><code>&lt;html&gt;</code></p><head><meta name="generator" content="Hexo 3.9.0"><title>APPLICATION对象_例1</title><head><meta name="generator" content="Hexo 3.9.0"></head></head><body><br>JSP(SERVLET)引擎名及版本号:<%=application.getserverinfo()%><br><br>返回/application1.jsp虚拟路径的真实路径:<%=application.getrealpath(" application1.jsp")%><br><br>服务器支持的Servlet API的大版本号:<%=application.getmajorversion()%><br><br>服务器支持的Servlet API的小版本号:<%=application.getminorversion()%><br><br>指定资源(文件及目录)的URL路径:<%=application.getresource(" application1.jsp")%><br><br><!--可以将application1.jsp换成一个目录--><br><br><% application.setattribute("name","霖苑计算机编程技术培训学校"); out.println(application.getattribute("name")); application.removeattribute("name"); %></%></%=application.getresource("></%=application.getminorversion()%></%=application.getmajorversion()%></%=application.getrealpath("></%=application.getserverinfo()%></body></%></%></%=session.isnew()?"是":"否"%></%=session.getmaxinactiveinterval()%></%=new></%=session.getlastaccessedtime()%></%=session.getid()%></%=new></%=session.getcreationtime()%></body></html><p><code>&lt;%@ page contentType=&quot;text/html;charset=gb2312&quot;%&gt;</code><br><code>&lt;html&gt;</code></p><head><meta name="generator" content="Hexo 3.9.0"><title>APPLICATION对象_例2</title><head><meta name="generator" content="Hexo 3.9.0"></head></head><body><br><!--由于application一直存在于服务器端，可以利用此特性对网页记数--><% if(application.getattribute("count")="=null)" application.setattribute("count","1"); else application.setattribute("count",integer.tostring(integer.valueof(application.getattribute("count").tostring()).intvalue()+1)); %>你是第<%=application.getattribute("count")%>位访问者</%=application.getattribute("count")%></%></body><!--由于getAttribute()方法得到的是一个Object类型对象,用getString()方法转化为String类型--><!--用Integer类的valueOf()方法把得到的String转化成Integer的对象,在用intValue()方法得到int型,再加1,最后把计算的结果用Integer.toString()方法转化成setAttribute()方法所要求的String类型--><p><code>&lt;%@ page contentType=&quot;text/html;charset=gb2312&quot;%&gt;</code><br><code>&lt;html&gt;</code></p><head><meta name="generator" content="Hexo 3.9.0"><title>APPLICATION对象_例3</title><head><meta name="generator" content="Hexo 3.9.0"></head></head><body><br><!--由于application一直存在于服务器端，可以利用此特性对网页记数--><% string str="application.getAttribute(" count").tostring(); getattribute("count")返回的是object类型" int i="0;" if(str="=null)" application.setattribute("count","1"); else out.println(i); application.setattribute("count",++i+""); %>你是第<%=application.getattribute("count")%>位访问者</%=application.getattribute("count")%></%><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginModelPath":"assets/","model":{"jsonPath":"/live2dw/assets/hijiki.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":false},"log":false,"pluginJsPath":"lib/","pluginRootPath":"live2dw/","tagMode":false});</script></body><h4 id="7-exception对象"><a href="#7-exception对象" class="headerlink" title="7.exception对象"></a>7.exception对象</h4><p>​    exception对象是一个例外对象，当一个页面在运行过程中发生了例外，就产生这个对象。如果一个JSP页面要应用此对象，就必须把isErrorPage设为true，否则无法编译。他实际上是java.lang.Throwable的对象</p><p>​    <code>序号方 法说 明1 String getMessage()返回描述异常的消息2 String toString()返回关于异常的简短描述消息3 void printStackTrace()显示异常及其栈轨迹4 Throwable FillInStackTrace()重写异常的执行栈轨迹</code></p><h4 id="8-pageContext对象"><a href="#8-pageContext对象" class="headerlink" title="8.pageContext对象"></a>8.pageContext对象</h4><p>​    pageContext对象提供了对JSP页面内所有的对象及名字空间的访问，也就是说他可以访问到本页所在的SESSION，也可以取本页面所在的application的某一属性值，他相当于页面中所有功能的集大成者，它的本 类名也叫pageContext。</p><p>​    <code>序号方 法说 明1 JspWriter getOut()返回当前客户端响应被使用的JspWriter流(out)2 HttpSession getSession()返回当前页中的HttpSession对象(session)3 Object getPage()返回当前页的Object对象(page)4 ServletRequest getRequest()返回当前页的ServletRequest对象(request)5 ServletResponse getResponse()返回当前页的ServletResponse对象(response)6 Exception getException()返回当前页的Exception对象(exception)7 ServletConfig getServletConfig()返回当前页的ServletConfig对象(config)8 ServletContext getServletContext()返回当前页的ServletContext对象(application)9 void setAttribute(String name,Object attribute)设置属性及属性值10 void setAttribute(String name,Object obj,int scope)在指定范围内设置属性及属性值11 public Object getAttribute(String name)取属性的值12 Object getAttribute(String name,int scope)在指定范围内取属性的值13 public Object findAttribute(String name)寻找一属性,返回起属性值或NULL14 void removeAttribute(String name)删除某属性15 void removeAttribute(String name,int scope)在指定范围删除某属性16 int getAttributeScope(String name)返回某属性的作用范围17 Enumeration getAttributeNamesInScope(int scope)返回指定范围内可用的属性名枚举18 void release()释放pageContext所占用的资源19 void forward(String relativeUrlPath)使当前页面重导到另一页面20 void include(String relativeUrlPath)在当前位置包含另一文件</code></p><p><code>&lt;%@page contentType=&quot;text/html;charset=gb2312&quot;%&gt;</code><br><code>&lt;html&gt;&lt;head&gt;&lt;title&gt;pageContext对象_例1&lt;/title&gt;&lt;/head&gt;</code><br><code>&lt;body&gt;&lt;br&gt;</code><br><code>&lt;%</code><br><code>request.setAttribute(&quot;name&quot;,&quot;霖苑编程&quot;);</code><br><code>session.setAttribute(&quot;name&quot;,&quot;霖苑计算机编程技术培训&quot;);</code><br><code>//session.putValue(&quot;name&quot;,&quot;计算机编程&quot;);</code><br><code>application.setAttribute(&quot;name&quot;,&quot;培训&quot;);</code><br><code>%&gt;</code><br><code>request设定的值：&lt;%=pageContext.getRequest().getAttribute(&quot;name&quot;)%&gt;&lt;br&gt;</code><br><code>session设定的值：&lt;%=pageContext.getSession().getAttribute(&quot;name&quot;)%&gt;&lt;br&gt;</code><br><code>application设定的值：&lt;%=pageContext.getServletContext().getAttribute(&quot;name&quot;)%&gt;&lt;br&gt;</code><br><code>范围1内的值：&lt;%=pageContext.getAttribute(&quot;name&quot;,1)%&gt;&lt;br&gt;</code><br><code>范围2内的值：&lt;%=pageContext.getAttribute(&quot;name&quot;,2)%&gt;&lt;br&gt;</code><br><code>范围3内的值：&lt;%=pageContext.getAttribute(&quot;name&quot;,3)%&gt;&lt;br&gt;</code><br><code>范围4内的值：&lt;%=pageContext.getAttribute(&quot;name&quot;,4)%&gt;&lt;br&gt;</code><br><code>&lt;!--从最小的范围page开始，然后是reques、session以及application--&gt;</code><br><code>&lt;%pageContext.removeAttribute(&quot;name&quot;,3);%&gt;</code><br><code>pageContext修改后的session设定的值：&lt;%=session.getValue(&quot;name&quot;)%&gt;&lt;br&gt;</code><br><code>&lt;%pageContext.setAttribute(&quot;name&quot;,&quot;应用技术培训&quot;,4);%&gt;</code><br><code>pageContext修改后的application设定的值：&lt;%=pageContext.getServletContext().getAttribute(&quot;name&quot;)%&gt;&lt;br&gt;</code><br><code>值的查找：&lt;%=pageContext.findAttribute(&quot;name&quot;)%&gt;&lt;br&gt;</code><br><code>属性name的范围：&lt;%=pageContext.getAttributesScope(&quot;name&quot;)%&gt;&lt;br&gt;</code><br><code>&lt;/body&gt;&lt;/html&gt;</code></p><h4 id="9-config对象"><a href="#9-config对象" class="headerlink" title="9.config对象"></a>9.config对象</h4><p>​    config对象是在一个Servlet初始化时，JSP引擎向它传递信息用的，此信息包括Servlet初始化时所要用到的参数（通过属性名和属性值构成）以及服务器的有关信息（通过传递一个ServletContext对象）</p><p>​    序号方 法说 明1 ServletContext getServletContext()返回含有服务器相关信息的ServletContext对象2 String getInitParameter(String name)返回初始化参数的值3 Enumeration getInitParameterNames()返回Servlet初始化所需所有参数的枚举</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;JSP九大内置对象&quot;&gt;&lt;a href=&quot;#JSP九大内置对象&quot; class=&quot;headerlink&quot; title=&quot;JSP九大内置对象&quot;&gt;&lt;/a&gt;JSP九大内置对象&lt;/h2&gt;&lt;h4 id=&quot;1-request对象&quot;&gt;&lt;a href=&quot;#1-request对象&quot; c
      
    
    </summary>
    
    
      <category term="JSP" scheme="https://wy200088.github.io/categories/JSP/"/>
    
    
      <category term="JSP" scheme="https://wy200088.github.io/tags/JSP/"/>
    
  </entry>
  
  <entry>
    <title>多态的有关讲解</title>
    <link href="https://wy200088.github.io/2019/10/24/%E5%A4%9A%E6%80%81%E7%9A%84%E6%9C%89%E5%85%B3%E8%AE%B2%E8%A7%A3/"/>
    <id>https://wy200088.github.io/2019/10/24/多态的有关讲解/</id>
    <published>2019-10-24T11:11:37.000Z</published>
    <updated>2019-11-14T07:51:34.621Z</updated>
    
    <content type="html"><![CDATA[<h3 id="JAVA多态讲解"><a href="#JAVA多态讲解" class="headerlink" title="JAVA多态讲解"></a>JAVA多态讲解</h3><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>什么叫多态？多态就是一种事物可以有多种表现形式</p><h3 id="多态三要素"><a href="#多态三要素" class="headerlink" title="多态三要素"></a>多态三要素</h3><p>1.被动方必须有继承关系</p><p>2.子类一般都要重写父类方法</p><p>3.必须将主动方的功能函数的参数设置为 被动方父类的类型</p><h3 id="举个例子司机开车"><a href="#举个例子司机开车" class="headerlink" title="举个例子司机开车"></a>举个例子司机开车</h3><p> 假如说司机会开汽车  我们需要定义个汽车的类  然后在司机类中添加会开汽车的的方法<br>假如说司机会开卡车 我们需要再定义一个卡车的类  然后在司机类中添加会开卡车的方法下面看下传统的调用方式  代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`<span class="class"><span class="keyword">class</span>` `<span class="title">Car</span>``</span>&#123;``    ``<span class="keyword">private</span>` `String name;` `    ``<span class="comment">//无参 构造方法``    ``public` `Car()&#123;&#125;``    ``// 有参构造方法``    ``public` `Car(String name)&#123;``        ``this``.name = name;``    ``&#125;``    ``public` `void` `setName(String name)&#123;``        ``this``.name = name;``    ``&#125;``    ``public` `String getName()&#123;``        ``return` `this``.name;``    ``&#125;``    ``public` `void` `run()&#123;&#125;``&#125;` `class` `Bus ``extends` `Car``&#123;``    ``public` `Bus()&#123;&#125;``    ``public` `Bus(String name)&#123;``        ``super``(name);``    ``&#125;``    ``public` `void` `run()&#123;``        ``System.out.println(``"公交车在跑"``);``    ``&#125;``&#125;` `class` `SmallCar ``extends` `Car``&#123;``    ``public` `SmallCar()&#123;&#125;``    ``public` `SmallCar(String name)&#123;``        ``super``(name);``    ``&#125;``    ``public` `void` `run()&#123;``        ``System.out.println(``"小轿车在跑"``);``    ``&#125;``&#125;` `class` `Drivers``&#123;``    ``//假如司机会开公交车``    ``public` `void` `driverBus(Bus b)&#123;``        ``b.run();``    ``&#125;` `    ``//假如司机会开小轿车``    ``public` `void` `driverSmallCar(SmallCar smcar)&#123;``        ``smcar.run();``    ``&#125;``&#125;`   `class`  `TestDt``&#123;``    ``public` `static` `void` `main(String[] args)``    ``&#123;``        ``Drivers d = ``new` `Drivers();``        ` `        ``//司机开公交车``        ``d.driverBus(``new` `Bus(``"公交车"``));``        ``d.driverSmallCar(``new` `SmallCar(``"小轿车"``));``    ``&#125;``&#125;`</span></span><br></pre></td></tr></table></figure><p> 正如上面的列子 在添加司机开其他的车 就会重复上面的行为 缺点是 扩展性比较差，后期代码维护困难。</p><p><strong>然后我们用多态的写法优化上述例子 代码如下：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`<span class="class"><span class="keyword">class</span>` `<span class="title">Car</span>``</span>&#123;``    ``<span class="keyword">private</span>` `String name;` `    ``<span class="comment">//无参 构造方法``    ``public` `Car()&#123;&#125;``    ``// 有参构造方法``    ``public` `Car(String name)&#123;``        ``this``.name = name;``    ``&#125;``    ``public` `void` `setName(String name)&#123;``        ``this``.name = name;``    ``&#125;``    ``public` `String getName()&#123;``        ``return` `this``.name;``    ``&#125;``    ``public` `void` `run()&#123;&#125;``&#125;` `class` `Bus ``extends` `Car``&#123;``    ``public` `Bus()&#123;&#125;``    ``public` `Bus(String name)&#123;``        ``super``(name);``    ``&#125;``    ``public` `void` `run()&#123;``        ``System.out.println(``"公交车在跑"``);``    ``&#125;``&#125;` `class` `SmallCar ``extends` `Car``&#123;``    ``public` `SmallCar()&#123;&#125;``    ``public` `SmallCar(String name)&#123;``        ``super``(name);``    ``&#125;``    ``public` `void` `run()&#123;``        ``System.out.println(``"小轿车在跑"``);``    ``&#125;``&#125;` `class` `Drivers``&#123;``    ``public` `void` `driverCar(Car car)&#123;``        ``car.run();``    ``&#125;``&#125;`   `class`  `TestDt``&#123;``    ``public` `static` `void` `main(String[] args)``    ``&#123;``        ``Drivers d = ``new` `Drivers();``        ` `        ``d.driverCar(``new` `Bus(``"公交车"``));``        ``d.driverCar(``new` `SmallCar(``"小轿车"``));``    ``&#125;``&#125;`</span></span><br></pre></td></tr></table></figure><p> 比较第一种写法  假如司机还会开其他的车 只需要添加会开这种车的类就行  司机类不需要再添加其它功能方法 。代码简介  后期维护比较方便  这种编写多态的形式也叫向上转型。</p><p>但是要想调用子类独有的方法必须向下转型才能调用</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;JAVA多态讲解&quot;&gt;&lt;a href=&quot;#JAVA多态讲解&quot; class=&quot;headerlink&quot; title=&quot;JAVA多态讲解&quot;&gt;&lt;/a&gt;JAVA多态讲解&lt;/h3&gt;&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
    
      <category term="JAVA" scheme="https://wy200088.github.io/categories/JAVA/"/>
    
    
      <category term="JAVA多态" scheme="https://wy200088.github.io/tags/JAVA%E5%A4%9A%E6%80%81/"/>
    
  </entry>
  
  <entry>
    <title>HTML 3D讲解</title>
    <link href="https://wy200088.github.io/2019/10/22/HTML-3D%E8%AE%B2%E8%A7%A3/"/>
    <id>https://wy200088.github.io/2019/10/22/HTML-3D讲解/</id>
    <published>2019-10-22T12:51:20.000Z</published>
    <updated>2019-11-06T03:07:48.908Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Html里的3D"><a href="#Html里的3D" class="headerlink" title="Html里的3D"></a>Html里的3D</h3><p>CSS3中的3D变换主要包括以下几种功能函数： 3D位移：CSS3中的3D位移主要包括translateZ()和translate3d()两个功能函数；  3D旋转：CSS3中的3D旋转主要包括rotateX()、rotateY()、rotateZ()和rotate3d()四个功能函数；  3D缩放：CSS3中的3D缩放主要包括scaleZ()和scale3d()两个功能函数；</p><p>景深</p><p>生活中的3d 区别于2d的地方</p><p>近大远小 景深程序中实现的方法 perspective 元素距离 视线的距离（物体和眼睛的距离越小，近大远小的效果越明显）perspective: 1200px;（在父元素中使用）transform:perspective(1200px) （在子元素中使用）两个都设置会发生冲突，建议只设置父元素，通常的数值在900-1200之间 如果当你的视线距离物体足够远的时候，基本上就不会有近大远小的感觉</p><p>perspective-origin;</p><p>观察3d元素的（位置）角度 perspective-origin：center center （中心）perspective-origin：left top （左上角）perspective-origin：100% 100% （右下角）</p><p>transform-style属性</p><p>transform-style属性是3D空间一个重要属性，指定嵌套元素如何在3D空间中呈现。他主要有两个属性值：flat和preserve-3d其中flat值为默认值，表示所有子元素在2D平面呈现。preserve-3d表示所有子元素在3D空间中呈现。也就是说，如果对一个元素设置了transform-style的值为flat，则该元素的所有子元素都将被平展到该元素的2D平面中进行呈现。沿着X轴或Y轴方向旋转该元素将导致位于正或负Z轴位置的子元素显示在该元素的平面上，而不是它的前面或者后面。如果对一个元素设置了transform-style的值为preserve-3d，它表示不执行平展操作，他的所有子元素位于3D空间中。</p><p>3d重要功能函数</p><p>1、 3D位移</p><p>在CSS3中3D位移主要包括两种函数translateZ()和translate3d()。translate3d()函数使一个元素在三维空间移动。 语法：translate3d(tx,ty,tz) tx：代表横向坐标位移向量的长度； ty：代表纵向坐标位移向量的长度； tz：代表Z轴位移向量的长度。此值不能是一个百分比值，如果取值为百分比值，将会认为无效值。 ranslateZ()函数的功能是让元素在3D空间沿Z轴进行位移。语法：translateZ(t) t：指的是Z轴的向量位移长度。</p><p>2、 3D旋转</p><p>在三维变形中，我们可以让元素在任何轴旋转。为此，CSS3新增三个旋转函数：rotateX()、rotateY()、rotateZ()和rotate3d(x,y,z,a)。</p><p>rotateX(a)</p><p>rotateX()函数指定一个元素围绕X轴旋转，旋转的量被定义为指定的角度；如果值为正值，元素围绕X轴顺时针旋转；反之，如果值为负值，元素围绕X轴逆时针旋转。</p><p>rotateY(a)</p><p>rotateY()函数指定一个元素围绕Y轴旋转，旋转的量被定义为指定的角度；如果值为正值，元素围绕Y轴顺时针旋转；反之，如果值为负值，元素围绕Y轴逆时针旋转。</p><p>rotateZ(a)</p><p>rotateZ()函数和其他两个函数功能一样的，区别在于rotateZ()函数指定一个元素围绕Z轴旋转。</p><p>rotate3d(x,y,z,a)</p><p>x：是一个0到１之间的数值，主要用来描述元素围绕X轴旋转的矢量值；y：是一个０到１之间的数值，主要用来描述元素围绕Y轴旋转的矢量值；z：是一个０到１之间的数值，主要用来描述元素围绕Z轴旋转的矢量值；a：是一个角度值，主要用来指定元素在3D空间旋转的角度，如果其值为正值，元素顺时针旋转，反之元素逆时针旋转。 </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Html里的3D&quot;&gt;&lt;a href=&quot;#Html里的3D&quot; class=&quot;headerlink&quot; title=&quot;Html里的3D&quot;&gt;&lt;/a&gt;Html里的3D&lt;/h3&gt;&lt;p&gt;CSS3中的3D变换主要包括以下几种功能函数： 3D位移：CSS3中的3D位移主要包括tra
      
    
    </summary>
    
    
      <category term="HTML" scheme="https://wy200088.github.io/categories/HTML/"/>
    
    
      <category term="html3D" scheme="https://wy200088.github.io/tags/html3D/"/>
    
  </entry>
  
  <entry>
    <title>JAVA知识点总结</title>
    <link href="https://wy200088.github.io/2019/10/13/JAVA%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"/>
    <id>https://wy200088.github.io/2019/10/13/JAVA知识点总结/</id>
    <published>2019-10-13T14:25:14.000Z</published>
    <updated>2019-11-14T07:53:00.730Z</updated>
    
    <content type="html"><![CDATA[<h3 id="JAVA面向对象知识点总结"><a href="#JAVA面向对象知识点总结" class="headerlink" title="JAVA面向对象知识点总结"></a>JAVA面向对象知识点总结</h3><p>第二章 类和对象</p><ul><li>1.面向对象概念：</li><li>2.类的创建</li><li>语法：public class 类名{}</li><li>File—&gt;new—&gt;class—&gt;类名</li><li>3.创建对象</li><li>类名 对象名=new 类名();</li><li>对象名.方法名(); 对象名.属性</li><li>4.构造方法：方法名和类名相同,没有返回值</li><li>public class 类名{</li><li>public 类名(){}//主要的做用是初始化操作</li><li>}</li><li>5.构造方法重载</li><li>在同一个类中，方法名相同，参数个数，顺序，类型不相同的构造方法</li><li>public class 类名{</li><li>public 类名(){}</li><li>public 类名(String name,int age){}</li><li>}</li><li>6.构造方法的执行</li><li>new 类名();—&gt;执行构造方法</li><li>super();—&gt;执行了父类的构造方法</li><li>7.static静态修饰符</li><li>静态修饰符可以修饰属性，方法，代码块</li><li>类名.属性      类名.方法名</li><li>8.java内存（栈和堆，static，方法区，gc（垃圾回收机制））</li><li></li><li>第三章 面向对象三大特征—封装</li><li>1.封装的概念</li><li>2.封装的步骤</li><li>1.把属性私有化（private）</li><li>2.对这些属性设置get和set方法</li><li>3.调用处理这些方法</li><li>3.封装的作用：避免一些用一些不合乎常理的操作</li><li>4.修饰符</li><li>public—&gt;公共的：在一个项目中都可以访问，权限最高</li><li>private—&gt;私有的：只能在本类中进行访问，权限最低</li><li>protected—&gt;安全的，受保护的：同一个包能进行访问，继承中之类可以访问父类</li><li>default—&gt;默认的：同一个包能访问</li><li>第四章 面向对象三大特征—继承</li><li>1.继承的概念：父亲儿子，电影《西虹市首富》</li><li>2.继承的关键字：extends</li><li>3.继承的语法：</li><li>public class 类名  extends 父类{}</li><li>4.使用，在之类中：</li><li>可以直接调用父类的非私有属性和方法</li><li>可以用super.方法     super.属性</li><li>5.父类构造方法调用：super();</li><li>调用父类的构造方法必须在之类中调用</li><li>必须实在之类构造方法的第一行代码</li><li>6.重写@Override</li><li>必须继承</li><li>方法名一致，参数个数，顺序，类型全部一致<br> 第五章 面向对象（多态）</li><li>1.多态的概念</li><li>2.多态的必要条件</li><li>继承</li><li>重写</li><li>父类引用指向子类对象（向上转型）</li><li>3.多态的使用</li><li>public class Father{</li><li>public void cooking(){</li><li>System.out.println(“米饭”);</li><li>}</li><li>}</li><li>public class Son extends Father{</li><li>@Override</li><li>public void cooking(){</li><li>System.out.println(“熬粥”);</li><li>}</li><li>}</li><li>public class Test {</li><li>public static void main(String[] args) {</li><li>Father son=new Son();</li><li>son.cooking();</li><li>}</li><li>}</li><li>4.向下转型</li><li>Son son=(Son)father;</li><li>第六章 抽象</li><li>1.抽象的概念</li><li>2.抽象的关键字</li><li>abstract</li><li>可以修饰类，可以修饰方法</li><li>3.抽象的用法</li><li>//抽象类</li><li>public abstract class 类名{</li><li>//抽象方法没有方法体</li><li>public abstract void 方法名();    </li><li>}</li><li>//当父类是抽象类的时候，子类必须重写父类里面的抽象方法</li><li>4.final修饰符：最终的</li><li>修饰变量，修饰方法，修饰类</li><li>1.当修饰变量时，变量转换成常量，常量的值不能改变</li><li>final int a=18;//a=18;不能改变,必须给一个初始值</li><li>2.当修饰方法时，该方法不能被重写</li><li>3.当修饰类时，该类不能被继承</li><li>第七章 接口</li><li>1.接口的概念</li><li>2.接口的关键字</li><li>interface</li><li>3.接口的语法</li><li>public interface 接口名{}</li><li>File—&gt;new—&gt;interface//创建接口</li><li>4.接口的用法</li><li>实现接口的关键字  implements</li><li>public interface 接口名{</li><li>//接口是纯抽象类</li><li>//接口里面的方法都是抽象方法</li><li>void setData();</li><li>}</li><li>public class Play implements 接口名{</li><li>@Override</li><li>void setData(){</li><li>}</li><li>}</li><li>public class Test {</li><li>public static void main(String[] args) {</li><li>Play play=new Play();</li><li>play.setData();</li><li>}</li><li>}</li><li>注意接口可以进行多继承</li><li>public interface 接口名 extends 接口名，接口名{}</li><li>一般用法</li><li>public class 类名 extends 父类 implements 接口，接口{}</li><li>第八章 集合框架</li><li>1.ArrayList</li><li>1.用法</li><li>ArrayList list=new ArrayList();</li><li>list.add();//添加数据</li><li>list.get();//获取数据</li><li>2.Map</li><li>用法</li><li>Map map=new HasMap();</li><li>map.put(key,value);//key不能重复</li><li>map.get(key);//获取key对象的value</li><li>3.泛型</li><li>ArrayList<string> list=new ArrayList&gt;<string>();</string></string></li><li>Map&lt;String,String&gt; map=new HasMap&lt;String,String&gt;();</li><li>ArrayList&lt;Map&lt;String,String&gt;&gt; list=new ArrayList&gt;&lt;Map&lt;String,String&gt;&gt;();</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;JAVA面向对象知识点总结&quot;&gt;&lt;a href=&quot;#JAVA面向对象知识点总结&quot; class=&quot;headerlink&quot; title=&quot;JAVA面向对象知识点总结&quot;&gt;&lt;/a&gt;JAVA面向对象知识点总结&lt;/h3&gt;&lt;p&gt;第二章 类和对象&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1.面向
      
    
    </summary>
    
    
      <category term="JAVA" scheme="https://wy200088.github.io/categories/JAVA/"/>
    
    
      <category term="JAVA总结" scheme="https://wy200088.github.io/tags/JAVA%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
</feed>
