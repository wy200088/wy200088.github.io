<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>JAVA对象内存图分析与详解</title>
    <link href="undefined2019/11/04/JAVA%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E5%9B%BE%E5%88%86%E6%9E%90%E4%B8%8E%E8%AF%A6%E8%A7%A3/"/>
    <url>2019/11/04/JAVA%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E5%9B%BE%E5%88%86%E6%9E%90%E4%B8%8E%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="JAVA对象内存图分析与详解"><a href="#JAVA对象内存图分析与详解" class="headerlink" title="JAVA对象内存图分析与详解"></a>JAVA对象内存图分析与详解</h1><p>讲Java对象内存图之前先了解一下以下几个概念：</p><p><img src="/2019/11/04/JAVA对象内存图分析与详解/D:%5Chexo%5Cblog%5Csource_posts%5CJAVA%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E5%9B%BE%E5%88%86%E6%9E%90%E4%B8%8E%E8%AF%A6%E8%A7%A3%5CIMGONE.jpg" srcset="/img/loading.gif" alt></p><p><font color="#100101" size="4" face="微软雅黑"><strong>堆区</strong></font>：1.存储new出来的对象，每个对象都包含一个与之对应的class的信息。(class的目的是得到操作指令) 2.jvm只有一个堆区(heap)被所有线程共享，堆中不存放基本类型和对象引用，只存放对象本身 。</p><p><font color="#100101" size="4" face="微软雅黑"><strong>栈区</strong></font>：1.每个线程包含一个栈区，栈中只保存基础数据类型的值和对象以及基础数据的引用。2.每个栈中的数据(基础数据类型和对象引用)都是私有的，其他栈不能访问。 3.栈分为3个部分：基本类型变量区、执行环境上下文、操作指令区(存放操作指令)</p><p><font color="#100101" size="4" face="微软雅黑"><strong>·方法区</strong></font>：1.又叫静态区，跟堆一样，被所有的线程共享。方法区包含所有的class和static变量。 2.方法区中包含的都是在整个程序中永远唯一的元素，如class，static变量。</p><p><img src="/2019/11/04/JAVA对象内存图分析与详解/D:%5Chexo%5Cblog%5Csource_posts%5CJAVA%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E5%9B%BE%E5%88%86%E6%9E%90%E4%B8%8E%E8%AF%A6%E8%A7%A3%5CIMGTWO.jpg" srcset="/img/loading.gif" alt></p><h2 id="对象内存图"><a href="#对象内存图" class="headerlink" title="对象内存图"></a>对象内存图</h2><h4 id="1、一个对象调用一个方法内存图"><a href="#1、一个对象调用一个方法内存图" class="headerlink" title="1、一个对象调用一个方法内存图"></a>1、一个对象调用一个方法内存图</h4><p><img src="/2019/11/04/JAVA对象内存图分析与详解/D:%5Chexo%5Cblog%5Csource_posts%5CJAVA%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E5%9B%BE%E5%88%86%E6%9E%90%E4%B8%8E%E8%AF%A6%E8%A7%A3%5CIMGTHREE.jpg" srcset="/img/loading.gif" alt></p><p>首先JVM运行一个class文件时，使用类加载器先将Demo类加载到方法区，然后main方法压栈（入栈）。</p><p>在栈中运行main方法，当jvm看到Phone时，会自动把Phone类加载到方法区；当看到局部变量p时，会在栈中开辟一块空间；当看到new Phone（）时，会在堆内存中开辟空间，并将堆内存中的对应地址0x123赋值给p;还会拿到方法区的地址值指向方法区。</p><p>·在main方法中运行到给对象p的属性赋值时，通过地址去堆内存中找到相应属性并赋值，运行p.sendMessage（）这一步时，也是根据地址值去堆内存中找到相应的对象，再用对象去方法区中找到sendMessage（）方法，然后将sendMessage（）方法压到栈中（入栈），调用完毕sendMessage（）方法会出栈。</p><p>·main方法运行结束后会出栈。</p><p>通过以上步骤描述，我们可以理解，在栈内存中运行的方法，遵循”先进后出，后进先出”的原则。变量p指向堆内存中的空间，寻找方法信息，去执行该方法。</p><h4 id="2、两个对象调用同一个方法内存图"><a href="#2、两个对象调用同一个方法内存图" class="headerlink" title="2、两个对象调用同一个方法内存图"></a>2、两个对象调用同一个方法内存图</h4><p><img src="/2019/11/04/JAVA对象内存图分析与详解/D:%5Chexo%5Cblog%5Csource_posts%5CJAVA%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E5%9B%BE%E5%88%86%E6%9E%90%E4%B8%8E%E8%AF%A6%E8%A7%A3%5CIMGFOUR.jpg" srcset="/img/loading.gif" alt></p><p>对象调用方法时，根据对象中方法标记（地址值），去类中寻找方法信息。这样哪怕是多个对象，方法信息只保存一份，节约内存空间。</p><h4 id="3、一个引用，作为参数传递到方法中内存图"><a href="#3、一个引用，作为参数传递到方法中内存图" class="headerlink" title="3、一个引用，作为参数传递到方法中内存图"></a>3、一个引用，作为参数传递到方法中内存图</h4><p><img src="/2019/11/04/JAVA对象内存图分析与详解/D:%5Chexo%5Cblog%5Csource_posts%5CJAVA%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E5%9B%BE%E5%88%86%E6%9E%90%E4%B8%8E%E8%AF%A6%E8%A7%A3%5CIMGFIVE.jpg" srcset="/img/loading.gif" alt></p><p>引用类型作为参数，传递的是地址值。</p>]]></content>
    
    
    <categories>
      
      <category>JAVA面向对象</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JAVA内存</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JSP九大内置对象</title>
    <link href="undefined2019/10/31/JSP%E4%B9%9D%E5%A4%A7%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1/"/>
    <url>2019/10/31/JSP%E4%B9%9D%E5%A4%A7%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1/</url>
    
    <content type="html"><![CDATA[<h2 id="JSP九大内置对象"><a href="#JSP九大内置对象" class="headerlink" title="JSP九大内置对象"></a>JSP九大内置对象</h2><h4 id="1-request对象"><a href="#1-request对象" class="headerlink" title="1.request对象"></a>1.request对象</h4><p>​    客户端的请求信息被封装在request对象中，通过它才能了解到客户的需求，然后做出响应。它是HttpServletRequest类的实例。</p><p>​    <code>序号方 法说 明1 object getAttribute(String name)返回指定属性的属性值2 Enumeration getAttributeNames()返回所有可用属性名的枚举3 String getCharacterEncoding()返回字符编码方式4 int getContentLength()返回请求体的长度（以字节数）5 String getContentType()得到请求体的MIME类型6 ServletInputStream getInputStream()得到请求体中一行的二进制流7 String getParameter(String name)返回name指定参数的参数值8 Enumeration getParameterNames()返回可用参数名的枚举9 String[] getParameterValues(String name)返回包含参数name的所有值的数组10 String getProtocol()返回请求用的协议类型及版本号11 String getScheme()返回请求用的计划名,如:http.https及ftp等12 String getServerName()返回接受请求的服务器主机名13 int getServerPort()返回服务器接受此请求所用的端口号14 BufferedReader getReader()返回解码过了的请求体15 String getRemoteAddr()返回发送此请求的客户端IP地址16 String getRemoteHost()返回发送此请求的客户端主机名17 void setAttribute(String key,Object obj)设置属性的属性值18 String getRealPath(String path)返回一虚拟路径的真实路径</code>.</p><p><code>&lt;%@ page contentType=&quot;text/html;charset=gb2312&quot;%&gt;</code><br><code>&lt;%request.setCharacterEncoding(&quot;gb2312&quot;);%&gt;</code><br><code>&lt;html&gt;</code></p><head><meta name="generator" content="Hexo 3.9.0"><title>request对象_例1</title></head>`<body bgcolor="#FFFFF0">`<form action method="post">  <input type="text" name="qwe">  <input type="submit" value="提交"></form>`请求方式：<%=request.getmethod()%><br>``请求的资源：<%=request.getrequesturi()%><br>``请求用的协议：<%=request.getprotocol()%><br>``请求的文件名：<%=request.getservletpath()%><br>``请求的服务器的IP：<%=request.getservername()%><br>``请求服务器的端口：<%=request.getserverport()%><br>``客户端IP地址：<%=request.getremoteaddr()%><br>``客户端主机名：<%=request.getremotehost()%><br>``表单提交来的值：<%=request.getparameter("qwe")%><br>``</%=request.getparameter("qwe")%></%=request.getremotehost()%></%=request.getremoteaddr()%></%=request.getserverport()%></%=request.getservername()%></%=request.getservletpath()%></%=request.getprotocol()%></%=request.getrequesturi()%></%=request.getmethod()%></body>```<p><code>&lt;%@ page contentType=&quot;text/html;charset=gb2312&quot;%&gt;</code><br><code>&lt;%request.setCharacterEncoding(&quot;gb2312&quot;);%&gt;</code><br><code>&lt;%@ page import=&quot;java.util.Enumeration&quot;%&gt;</code><br><code>&lt;html&gt;</code></p><head><meta name="generator" content="Hexo 3.9.0">  <title>request对象_例2</title></head>`<body bgcolor="#FFFFF0">`<form action method="post">   用户名：<input type="text" name="username">&nbsp;&nbsp;   密 码：<input type="text" name="userpass">&nbsp;&nbsp;   <input type="submit" value="进入"></form>`<%` `string str ;` `if(request.getparameter("username")!="null" && request.getparameter("userpass")!="null){`" `enumeration enumt="request.getParameterNames();`" `while(enumt.hasmoreelements()){` `str="enumt.nextElement().toString();`" `out.println(str+":"+request.getparameter(str)+"<br>");`   `}``}``%>``</%`></body>```<p><code>&lt;%@ page contentType=&quot;text/html;charset=gb2312&quot;%&gt;</code><br><code>&lt;%request.setCharacterEncoding(&quot;gb2312&quot;);%&gt;</code><br><code>&lt;html&gt;</code></p><head><meta name="generator" content="Hexo 3.9.0">   <title>request对象_例3</title></head>`<body bgcolor="#FFFFF0">`<form action method="post">  擅长：<input type="checkbox" name="cb" value="ON1">VC++&nbsp;       <input type="checkbox" name="cb" value="ON2">JAVA&nbsp;       <input type="checkbox" name="cb" value="ON3">DELPHI&nbsp;       <input type="checkbox" name="cb" value="ON4">VB&nbsp;       <br>       <input type="submit" value="进入" name="qwe"></form>`<%` `if(request.getparameter("qwe")!="null" ){` `for(int i="0;i<request.getParameterValues(" cb").length;i++){`" `out.println("cb"+i+":"+request.getparametervalues("cb")[i]+"<br>");`   `}`   `out.println(request.getParameter("qwe"));``}``%>``</%`></body>```<h4 id="2-response对象"><a href="#2-response对象" class="headerlink" title="2.response对象"></a>2.response对象</h4><p>​    response对象包含了响应客户请求的有关信息，但在JSP中很少直接用到它。它是HttpServletResponse类的实例。</p><p>​    <code>序号方 法说 明1 String getCharacterEncoding()返回响应用的是何种字符编码2 ServletOutputStream getOutputStream()返回响应的一个二进制输出流3 PrintWriter getWriter()返回可以向客户端输出字符的一个对象4 void setContentLength(int len)设置响应头长度5 void setContentType(String type)设置响应的MIME类型6 sendRedirect(java.lang.String location)重新定向客户端的请求</code>.</p><h4 id="3-session对象"><a href="#3-session对象" class="headerlink" title="3.session对象"></a>3.session对象</h4><p>​    session对象指的是客户端与服务器的一次会话，从客户连到服务器的一个WebApplication开始，直到客户端与服务器断开连接为止。它是HttpSession类的实例.</p><p>​    <code>序号方 法说 明1 long getCreationTime()返回SESSION创建时间2 public String getId()返回SESSION创建时JSP引擎为它设的惟一ID号3 long getLastAccessedTime()返回此SESSION里客户端最近一次请求时间4 int getMaxInactiveInterval()返回两次请求间隔多长时间此SESSION被取消(ms)5 String[] getValueNames()返回一个包含此SESSION中所有可用属性的数组6 void invalidate()取消SESSION，使SESSION不可用7 boolean isNew()返回服务器创建的一个SESSION,客户端是否已经加入8 void removeValue(String name)删除SESSION中指定的属性9 void setMaxInactiveInterval()设置两次请求间隔多长时间此SESSION被取消(ms)</code></p><p>`&lt;%@ page contentType=”text/html;charset=gb2312”%&gt;<br>&lt;%@ page import=”java.util.*” %&gt;</p><html>`<head><meta name="generator" content="Hexo 3.9.0"><title>session对象_例1</title><head><meta name="generator" content="Hexo 3.9.0"></head></head><body><br>   session的创建时间:<%=session.getcreationtime()%>&nbsp;&nbsp;<%=new date(session.getcreationtime())%><br><br>   session的Id号:<%=session.getid()%><br><br>   客户端最近一次请求时间:<%=session.getlastaccessedtime()%>&nbsp;&nbsp;<%=new java.sql. time(session.getlastaccessedtime())%><br><br>   两次请求间隔多长时间此SESSION被取消(ms):<%=session.getmaxinactiveinterval()%><br><br>   是否是新创建的一个SESSION:<%=session.isnew()?"是":"否"%><br><br><% session.putvalue("name","霖苑编程"); session.putvalue("nmber","147369"); %><% for(int i="0;i<session.getValueNames().length;i++)" out.println(session.getvaluenames()[i]+"="+session.getValue(session.getValueNames()[i]));%><!--返回的是从格林威治时间(GMT)1970年01月01日0：00：00起到计算当时的毫秒数--></body></html><h4 id=" 4-out对象"><a href="#4-out对象" class="headerlink" title="4.out对象"></a>4.out对象<p>​    out对象是JspWriter类的实例,是向客户端输出内容常用的对象</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">序号方 法说 明<span class="number">1</span> <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span>清除缓冲区的内容2 <span class="keyword">void</span> <span class="title">clearBuffer</span><span class="params">()</span>清除缓冲区的当前内容3 <span class="keyword">void</span> <span class="title">flush</span><span class="params">()</span>清空流4 <span class="keyword">int</span> <span class="title">getBufferSize</span><span class="params">()</span>返回缓冲区以字节数的大小，如不设缓冲区则为05 <span class="keyword">int</span> <span class="title">getRemaining</span><span class="params">()</span>返回缓冲区还剩余多少可用6 <span class="keyword">boolean</span> <span class="title">isAutoFlush</span><span class="params">()</span>返回缓冲区满时，是自动清空还是抛出异常7 <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span>关闭输出流</span></span><br></pre></td></tr></table></figure><p><code>&lt;%@page contentType=&quot;text/html;charset=gb2312&quot;%&gt;</code><br><code>&lt;html&gt;&lt;head&gt;&lt;title&gt;out对象_例1:缓存测试&lt;/title&gt;&lt;/head&gt;</code><br><code>&lt;%@page buffer=&quot;1kb&quot;%&gt;</code><br><code>&lt;body&gt;</code><br><code>&lt;%</code><br>  <code>for(int i=0;i&lt;2000;i++)</code><br>  <code>out.println(i+&quot;{&quot;+out.getRemaining()+&quot;}&quot;);</code><br><code>%&gt;&lt;br&gt;</code><br><code>缓存大小：&lt;%=out.getBufferSize()%&gt;&lt;br&gt;</code><br><code>剩余缓存大小：&lt;%=out.getRemaining()%&gt;&lt;br&gt;</code><br><code>自动刷新：&lt;%=out.isAutoFlush()%&gt;&lt;br&gt;</code><br><code>&lt;%--out.clearBuffer();--%&gt;</code><br><code>&lt;%--out.clear();--%&gt;</code><br><code>&lt;!--缺省情况下:服务端要输出到客户端的内容,不直接写到客户端,而是先写到一个输出缓冲区中.只有在下面三中情况下，才会把该缓冲区的内容输出到客户端上： 1.该JSP网页已完成信息的输出 2.输出缓冲区已满 3.JSP中调用了out.flush()或response.flushbuffer() --&gt;</code><br><code>&lt;/body&gt;</code><br><code>&lt;/html&gt;</code></p><h4 id="5-page对象"><a href="#5-page对象" class="headerlink" title="5.page对象"></a>5.page对象</h4><p>​    page对象就是指向当前JSP页面本身，有点象类中的this指针，它是java.lang.Object类的实例</p><p>​    <code>序号方 法说 明1 class getClass返回此Object的类2 int hashCode()返回此Object的hash码3 boolean equals(Object obj)判断此Object是否与指定的Object对象相等4 void copy(Object obj)把此Object拷贝到指定的Object对象中5 Object clone()克隆此Object对象6 String toString()把此Object对象转换成String类的对象7 void notify()唤醒一个等待的线程8 void notifyAll()唤醒所有等待的线程9 void wait(int timeout)使一个线程处于等待直到timeout结束或被唤醒10 void wait()使一个线程处于等待直到被唤醒11 void enterMonitor()对Object加锁12 void exitMonitor()对Object开锁</code></p><h4 id="6-application对象"><a href="#6-application对象" class="headerlink" title="6.application对象"></a>6.application对象</h4><p>​    application对象实现了用户间数据的共享，可存放全局变量。它开始于服务器的启动，直到服务器的关闭，在此期间，此对象将一直存在；这样在用户的前后连接或不同用户之间的连接中，可以对此对象的同一属性进行操作；在任何地方对此对象属性的操作，都将影响到其他用户对此的访问。服务器的启动和关闭决定了application对象的生命。它是ServletContext类的实例。</p><p>​    <code>序号方 法说 明1 Object getAttribute(String name)返回给定名的属性值2 Enumeration getAttributeNames()返回所有可用属性名的枚举3 void setAttribute(String name,Object obj)设定属性的属性值4 void removeAttribute(String name)删除一属性及其属性值5 String getServerInfo()返回JSP(SERVLET)引擎名及版本号6 String getRealPath(String path)返回一虚拟路径的真实路径7 ServletContext getContext(String uripath)返回指定WebApplication的application对象8 int getMajorVersion()返回服务器支持的Servlet API的最大版本号9 int getMinorVersion()返回服务器支持的Servlet API的最大版本号10 String getMimeType(String file)返回指定文件的MIME类型11 URL getResource(String path)返回指定资源(文件及目录)的URL路径12 InputStream getResourceAsStream(String path)返回指定资源的输入流13 RequestDispatcher getRequestDispatcher(String uripath)返回指定资源的RequestDispatcher对象14 Servlet getServlet(String name)返回指定名的Servlet15 Enumeration getServlets()返回所有Servlet的枚举16 Enumeration getServletNames()返回所有Servlet名的枚举17 void log(String msg)把指定消息写入Servlet的日志文件18 void log(Exception exception,String msg)把指定异常的栈轨迹及错误消息写入Servlet的日志文件19 void log(String msg,Throwable throwable)把栈轨迹及给出的Throwable异常的说明信息 写入Servlet的日志文件</code>.</p><p><code>&lt;%@ page contentType=&quot;text/html;charset=gb2312&quot;%&gt;</code><br><code>&lt;html&gt;</code></p><head><meta name="generator" content="Hexo 3.9.0"><title>APPLICATION对象_例1</title><head><meta name="generator" content="Hexo 3.9.0"></head></head><body><br>JSP(SERVLET)引擎名及版本号:<%=application.getserverinfo()%><br><br>返回/application1.jsp虚拟路径的真实路径:<%=application.getrealpath(" application1.jsp")%><br><br>服务器支持的Servlet API的大版本号:<%=application.getmajorversion()%><br><br>服务器支持的Servlet API的小版本号:<%=application.getminorversion()%><br><br>指定资源(文件及目录)的URL路径:<%=application.getresource(" application1.jsp")%><br><br><!--可以将application1.jsp换成一个目录--><br><br><% application.setattribute("name","霖苑计算机编程技术培训学校"); out.println(application.getattribute("name")); application.removeattribute("name"); %></%></%=application.getresource("></%=application.getminorversion()%></%=application.getmajorversion()%></%=application.getrealpath("></%=application.getserverinfo()%></body></%></%></%=session.isnew()?"是":"否"%></%=session.getmaxinactiveinterval()%></%=new></%=session.getlastaccessedtime()%></%=session.getid()%></%=new></%=session.getcreationtime()%></body></html><p><code>&lt;%@ page contentType=&quot;text/html;charset=gb2312&quot;%&gt;</code><br><code>&lt;html&gt;</code></p><head><meta name="generator" content="Hexo 3.9.0"><title>APPLICATION对象_例2</title><head><meta name="generator" content="Hexo 3.9.0"></head></head><body><br><!--由于application一直存在于服务器端，可以利用此特性对网页记数--><% if(application.getattribute("count")="=null)" application.setattribute("count","1"); else application.setattribute("count",integer.tostring(integer.valueof(application.getattribute("count").tostring()).intvalue()+1)); %>你是第<%=application.getattribute("count")%>位访问者</%=application.getattribute("count")%></%></body><!--由于getAttribute()方法得到的是一个Object类型对象,用getString()方法转化为String类型--><!--用Integer类的valueOf()方法把得到的String转化成Integer的对象,在用intValue()方法得到int型,再加1,最后把计算的结果用Integer.toString()方法转化成setAttribute()方法所要求的String类型--><p><code>&lt;%@ page contentType=&quot;text/html;charset=gb2312&quot;%&gt;</code><br><code>&lt;html&gt;</code></p><head><meta name="generator" content="Hexo 3.9.0"><title>APPLICATION对象_例3</title><head><meta name="generator" content="Hexo 3.9.0"></head></head><body><br><!--由于application一直存在于服务器端，可以利用此特性对网页记数--><% string str="application.getAttribute(" count").tostring(); getattribute("count")返回的是object类型" int i="0;" if(str="=null)" application.setattribute("count","1"); else out.println(i); application.setattribute("count",++i+""); %>你是第<%=application.getattribute("count")%>位访问者</%=application.getattribute("count")%></%><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginModelPath":"assets/","model":{"jsonPath":"live2d-widget-model-hijiki"},"display":{"position":"right","width":250,"height":450},"mobile":{"show":false},"log":false,"pluginJsPath":"lib/","pluginRootPath":"live2dw/","tagMode":false});</script></body><h4 id="7-exception对象"><a href="#7-exception对象" class="headerlink" title="7.exception对象"></a>7.exception对象</h4><p>​    exception对象是一个例外对象，当一个页面在运行过程中发生了例外，就产生这个对象。如果一个JSP页面要应用此对象，就必须把isErrorPage设为true，否则无法编译。他实际上是java.lang.Throwable的对象</p><p>​    <code>序号方 法说 明1 String getMessage()返回描述异常的消息2 String toString()返回关于异常的简短描述消息3 void printStackTrace()显示异常及其栈轨迹4 Throwable FillInStackTrace()重写异常的执行栈轨迹</code></p><h4 id="8-pageContext对象"><a href="#8-pageContext对象" class="headerlink" title="8.pageContext对象"></a>8.pageContext对象</h4><p>​    pageContext对象提供了对JSP页面内所有的对象及名字空间的访问，也就是说他可以访问到本页所在的SESSION，也可以取本页面所在的application的某一属性值，他相当于页面中所有功能的集大成者，它的本 类名也叫pageContext。</p><p>​    <code>序号方 法说 明1 JspWriter getOut()返回当前客户端响应被使用的JspWriter流(out)2 HttpSession getSession()返回当前页中的HttpSession对象(session)3 Object getPage()返回当前页的Object对象(page)4 ServletRequest getRequest()返回当前页的ServletRequest对象(request)5 ServletResponse getResponse()返回当前页的ServletResponse对象(response)6 Exception getException()返回当前页的Exception对象(exception)7 ServletConfig getServletConfig()返回当前页的ServletConfig对象(config)8 ServletContext getServletContext()返回当前页的ServletContext对象(application)9 void setAttribute(String name,Object attribute)设置属性及属性值10 void setAttribute(String name,Object obj,int scope)在指定范围内设置属性及属性值11 public Object getAttribute(String name)取属性的值12 Object getAttribute(String name,int scope)在指定范围内取属性的值13 public Object findAttribute(String name)寻找一属性,返回起属性值或NULL14 void removeAttribute(String name)删除某属性15 void removeAttribute(String name,int scope)在指定范围删除某属性16 int getAttributeScope(String name)返回某属性的作用范围17 Enumeration getAttributeNamesInScope(int scope)返回指定范围内可用的属性名枚举18 void release()释放pageContext所占用的资源19 void forward(String relativeUrlPath)使当前页面重导到另一页面20 void include(String relativeUrlPath)在当前位置包含另一文件</code></p><p><code>&lt;%@page contentType=&quot;text/html;charset=gb2312&quot;%&gt;</code><br><code>&lt;html&gt;&lt;head&gt;&lt;title&gt;pageContext对象_例1&lt;/title&gt;&lt;/head&gt;</code><br><code>&lt;body&gt;&lt;br&gt;</code><br><code>&lt;%</code><br><code>request.setAttribute(&quot;name&quot;,&quot;霖苑编程&quot;);</code><br><code>session.setAttribute(&quot;name&quot;,&quot;霖苑计算机编程技术培训&quot;);</code><br><code>//session.putValue(&quot;name&quot;,&quot;计算机编程&quot;);</code><br><code>application.setAttribute(&quot;name&quot;,&quot;培训&quot;);</code><br><code>%&gt;</code><br><code>request设定的值：&lt;%=pageContext.getRequest().getAttribute(&quot;name&quot;)%&gt;&lt;br&gt;</code><br><code>session设定的值：&lt;%=pageContext.getSession().getAttribute(&quot;name&quot;)%&gt;&lt;br&gt;</code><br><code>application设定的值：&lt;%=pageContext.getServletContext().getAttribute(&quot;name&quot;)%&gt;&lt;br&gt;</code><br><code>范围1内的值：&lt;%=pageContext.getAttribute(&quot;name&quot;,1)%&gt;&lt;br&gt;</code><br><code>范围2内的值：&lt;%=pageContext.getAttribute(&quot;name&quot;,2)%&gt;&lt;br&gt;</code><br><code>范围3内的值：&lt;%=pageContext.getAttribute(&quot;name&quot;,3)%&gt;&lt;br&gt;</code><br><code>范围4内的值：&lt;%=pageContext.getAttribute(&quot;name&quot;,4)%&gt;&lt;br&gt;</code><br><code>&lt;!--从最小的范围page开始，然后是reques、session以及application--&gt;</code><br><code>&lt;%pageContext.removeAttribute(&quot;name&quot;,3);%&gt;</code><br><code>pageContext修改后的session设定的值：&lt;%=session.getValue(&quot;name&quot;)%&gt;&lt;br&gt;</code><br><code>&lt;%pageContext.setAttribute(&quot;name&quot;,&quot;应用技术培训&quot;,4);%&gt;</code><br><code>pageContext修改后的application设定的值：&lt;%=pageContext.getServletContext().getAttribute(&quot;name&quot;)%&gt;&lt;br&gt;</code><br><code>值的查找：&lt;%=pageContext.findAttribute(&quot;name&quot;)%&gt;&lt;br&gt;</code><br><code>属性name的范围：&lt;%=pageContext.getAttributesScope(&quot;name&quot;)%&gt;&lt;br&gt;</code><br><code>&lt;/body&gt;&lt;/html&gt;</code></p><h4 id="9-config对象"><a href="#9-config对象" class="headerlink" title="9.config对象"></a>9.config对象</h4><p>​    config对象是在一个Servlet初始化时，JSP引擎向它传递信息用的，此信息包括Servlet初始化时所要用到的参数（通过属性名和属性值构成）以及服务器的有关信息（通过传递一个ServletContext对象）</p><p>​    序号方 法说 明1 ServletContext getServletContext()返回含有服务器相关信息的ServletContext对象2 String getInitParameter(String name)返回初始化参数的值3 Enumeration getInitParameterNames()返回Servlet初始化所需所有参数的枚举</p>]]></content>
    
    
    <categories>
      
      <category>JSP内置对象</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JSP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>多态的有关讲解</title>
    <link href="undefined2019/10/24/%E5%A4%9A%E6%80%81%E7%9A%84%E6%9C%89%E5%85%B3%E8%AE%B2%E8%A7%A3/"/>
    <url>2019/10/24/%E5%A4%9A%E6%80%81%E7%9A%84%E6%9C%89%E5%85%B3%E8%AE%B2%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h3 id="JAVA多态讲解"><a href="#JAVA多态讲解" class="headerlink" title="JAVA多态讲解"></a>JAVA多态讲解</h3><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>什么叫多态？多态就是一种事物可以有多种表现形式</p><h3 id="多态三要素"><a href="#多态三要素" class="headerlink" title="多态三要素"></a>多态三要素</h3><p>1.被动方必须有继承关系</p><p>2.子类一般都要重写父类方法</p><p>3.必须将主动方的功能函数的参数设置为 被动方父类的类型</p><h3 id="举个例子司机开车"><a href="#举个例子司机开车" class="headerlink" title="举个例子司机开车"></a>举个例子司机开车</h3><p> 假如说司机会开汽车  我们需要定义个汽车的类  然后在司机类中添加会开汽车的的方法<br>假如说司机会开卡车 我们需要再定义一个卡车的类  然后在司机类中添加会开卡车的方法下面看下传统的调用方式  代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`<span class="class"><span class="keyword">class</span>` `<span class="title">Car</span>``</span>&#123;``    ``<span class="keyword">private</span>` `String name;` `    ``<span class="comment">//无参 构造方法``    ``public` `Car()&#123;&#125;``    ``// 有参构造方法``    ``public` `Car(String name)&#123;``        ``this``.name = name;``    ``&#125;``    ``public` `void` `setName(String name)&#123;``        ``this``.name = name;``    ``&#125;``    ``public` `String getName()&#123;``        ``return` `this``.name;``    ``&#125;``    ``public` `void` `run()&#123;&#125;``&#125;` `class` `Bus ``extends` `Car``&#123;``    ``public` `Bus()&#123;&#125;``    ``public` `Bus(String name)&#123;``        ``super``(name);``    ``&#125;``    ``public` `void` `run()&#123;``        ``System.out.println(``"公交车在跑"``);``    ``&#125;``&#125;` `class` `SmallCar ``extends` `Car``&#123;``    ``public` `SmallCar()&#123;&#125;``    ``public` `SmallCar(String name)&#123;``        ``super``(name);``    ``&#125;``    ``public` `void` `run()&#123;``        ``System.out.println(``"小轿车在跑"``);``    ``&#125;``&#125;` `class` `Drivers``&#123;``    ``//假如司机会开公交车``    ``public` `void` `driverBus(Bus b)&#123;``        ``b.run();``    ``&#125;` `    ``//假如司机会开小轿车``    ``public` `void` `driverSmallCar(SmallCar smcar)&#123;``        ``smcar.run();``    ``&#125;``&#125;`   `class`  `TestDt``&#123;``    ``public` `static` `void` `main(String[] args)``    ``&#123;``        ``Drivers d = ``new` `Drivers();``        ` `        ``//司机开公交车``        ``d.driverBus(``new` `Bus(``"公交车"``));``        ``d.driverSmallCar(``new` `SmallCar(``"小轿车"``));``    ``&#125;``&#125;`</span></span><br></pre></td></tr></table></figure><p> 正如上面的列子 在添加司机开其他的车 就会重复上面的行为 缺点是 扩展性比较差，后期代码维护困难。</p><p><strong>然后我们用多态的写法优化上述例子 代码如下：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`<span class="class"><span class="keyword">class</span>` `<span class="title">Car</span>``</span>&#123;``    ``<span class="keyword">private</span>` `String name;` `    ``<span class="comment">//无参 构造方法``    ``public` `Car()&#123;&#125;``    ``// 有参构造方法``    ``public` `Car(String name)&#123;``        ``this``.name = name;``    ``&#125;``    ``public` `void` `setName(String name)&#123;``        ``this``.name = name;``    ``&#125;``    ``public` `String getName()&#123;``        ``return` `this``.name;``    ``&#125;``    ``public` `void` `run()&#123;&#125;``&#125;` `class` `Bus ``extends` `Car``&#123;``    ``public` `Bus()&#123;&#125;``    ``public` `Bus(String name)&#123;``        ``super``(name);``    ``&#125;``    ``public` `void` `run()&#123;``        ``System.out.println(``"公交车在跑"``);``    ``&#125;``&#125;` `class` `SmallCar ``extends` `Car``&#123;``    ``public` `SmallCar()&#123;&#125;``    ``public` `SmallCar(String name)&#123;``        ``super``(name);``    ``&#125;``    ``public` `void` `run()&#123;``        ``System.out.println(``"小轿车在跑"``);``    ``&#125;``&#125;` `class` `Drivers``&#123;``    ``public` `void` `driverCar(Car car)&#123;``        ``car.run();``    ``&#125;``&#125;`   `class`  `TestDt``&#123;``    ``public` `static` `void` `main(String[] args)``    ``&#123;``        ``Drivers d = ``new` `Drivers();``        ` `        ``d.driverCar(``new` `Bus(``"公交车"``));``        ``d.driverCar(``new` `SmallCar(``"小轿车"``));``    ``&#125;``&#125;`</span></span><br></pre></td></tr></table></figure><p> 比较第一种写法  假如司机还会开其他的车 只需要添加会开这种车的类就行  司机类不需要再添加其它功能方法 。代码简介  后期维护比较方便  这种编写多态的形式也叫向上转型。</p><p>但是要想调用子类独有的方法必须向下转型才能调用</p>]]></content>
    
    
    <categories>
      
      <category>JAVA面向对象</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JAVA多态</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HTML 3D讲解</title>
    <link href="undefined2019/10/22/HTML-3D%E8%AE%B2%E8%A7%A3/"/>
    <url>2019/10/22/HTML-3D%E8%AE%B2%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h3 id="Html里的3D"><a href="#Html里的3D" class="headerlink" title="Html里的3D"></a>Html里的3D</h3><p>CSS3中的3D变换主要包括以下几种功能函数： 3D位移：CSS3中的3D位移主要包括translateZ()和translate3d()两个功能函数；  3D旋转：CSS3中的3D旋转主要包括rotateX()、rotateY()、rotateZ()和rotate3d()四个功能函数；  3D缩放：CSS3中的3D缩放主要包括scaleZ()和scale3d()两个功能函数；</p><p>景深</p><p>生活中的3d 区别于2d的地方</p><p>近大远小 景深程序中实现的方法 perspective 元素距离 视线的距离（物体和眼睛的距离越小，近大远小的效果越明显）perspective: 1200px;（在父元素中使用）transform:perspective(1200px) （在子元素中使用）两个都设置会发生冲突，建议只设置父元素，通常的数值在900-1200之间 如果当你的视线距离物体足够远的时候，基本上就不会有近大远小的感觉</p><p>perspective-origin;</p><p>观察3d元素的（位置）角度 perspective-origin：center center （中心）perspective-origin：left top （左上角）perspective-origin：100% 100% （右下角）</p><p>transform-style属性</p><p>transform-style属性是3D空间一个重要属性，指定嵌套元素如何在3D空间中呈现。他主要有两个属性值：flat和preserve-3d其中flat值为默认值，表示所有子元素在2D平面呈现。preserve-3d表示所有子元素在3D空间中呈现。也就是说，如果对一个元素设置了transform-style的值为flat，则该元素的所有子元素都将被平展到该元素的2D平面中进行呈现。沿着X轴或Y轴方向旋转该元素将导致位于正或负Z轴位置的子元素显示在该元素的平面上，而不是它的前面或者后面。如果对一个元素设置了transform-style的值为preserve-3d，它表示不执行平展操作，他的所有子元素位于3D空间中。</p><p>3d重要功能函数</p><p>1、 3D位移</p><p>在CSS3中3D位移主要包括两种函数translateZ()和translate3d()。translate3d()函数使一个元素在三维空间移动。 语法：translate3d(tx,ty,tz) tx：代表横向坐标位移向量的长度； ty：代表纵向坐标位移向量的长度； tz：代表Z轴位移向量的长度。此值不能是一个百分比值，如果取值为百分比值，将会认为无效值。 ranslateZ()函数的功能是让元素在3D空间沿Z轴进行位移。语法：translateZ(t) t：指的是Z轴的向量位移长度。</p><p>2、 3D旋转</p><p>在三维变形中，我们可以让元素在任何轴旋转。为此，CSS3新增三个旋转函数：rotateX()、rotateY()、rotateZ()和rotate3d(x,y,z,a)。</p><p>rotateX(a)</p><p>rotateX()函数指定一个元素围绕X轴旋转，旋转的量被定义为指定的角度；如果值为正值，元素围绕X轴顺时针旋转；反之，如果值为负值，元素围绕X轴逆时针旋转。</p><p>rotateY(a)</p><p>rotateY()函数指定一个元素围绕Y轴旋转，旋转的量被定义为指定的角度；如果值为正值，元素围绕Y轴顺时针旋转；反之，如果值为负值，元素围绕Y轴逆时针旋转。</p><p>rotateZ(a)</p><p>rotateZ()函数和其他两个函数功能一样的，区别在于rotateZ()函数指定一个元素围绕Z轴旋转。</p><p>rotate3d(x,y,z,a)</p><p>x：是一个0到１之间的数值，主要用来描述元素围绕X轴旋转的矢量值；y：是一个０到１之间的数值，主要用来描述元素围绕Y轴旋转的矢量值；z：是一个０到１之间的数值，主要用来描述元素围绕Z轴旋转的矢量值；a：是一个角度值，主要用来指定元素在3D空间旋转的角度，如果其值为正值，元素顺时针旋转，反之元素逆时针旋转。 </p>]]></content>
    
    
    <categories>
      
      <category>Web3D</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Web</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JAVA知识点总结</title>
    <link href="undefined2019/10/13/JAVA%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"/>
    <url>2019/10/13/JAVA%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h3 id="JAVA面向对象知识点总结"><a href="#JAVA面向对象知识点总结" class="headerlink" title="JAVA面向对象知识点总结"></a>JAVA面向对象知识点总结</h3><p>第二章 类和对象</p><ul><li>1.面向对象概念：</li><li>2.类的创建</li><li>语法：public class 类名{}</li><li>File—&gt;new—&gt;class—&gt;类名</li><li>3.创建对象</li><li>类名 对象名=new 类名();</li><li>对象名.方法名(); 对象名.属性</li><li>4.构造方法：方法名和类名相同,没有返回值</li><li>public class 类名{</li><li>public 类名(){}//主要的做用是初始化操作</li><li>}</li><li>5.构造方法重载</li><li>在同一个类中，方法名相同，参数个数，顺序，类型不相同的构造方法</li><li>public class 类名{</li><li>public 类名(){}</li><li>public 类名(String name,int age){}</li><li>}</li><li>6.构造方法的执行</li><li>new 类名();—&gt;执行构造方法</li><li>super();—&gt;执行了父类的构造方法</li><li>7.static静态修饰符</li><li>静态修饰符可以修饰属性，方法，代码块</li><li>类名.属性      类名.方法名</li><li>8.java内存（栈和堆，static，方法区，gc（垃圾回收机制））</li><li></li><li>第三章 面向对象三大特征—封装</li><li>1.封装的概念</li><li>2.封装的步骤</li><li>1.把属性私有化（private）</li><li>2.对这些属性设置get和set方法</li><li>3.调用处理这些方法</li><li>3.封装的作用：避免一些用一些不合乎常理的操作</li><li>4.修饰符</li><li>public—&gt;公共的：在一个项目中都可以访问，权限最高</li><li>private—&gt;私有的：只能在本类中进行访问，权限最低</li><li>protected—&gt;安全的，受保护的：同一个包能进行访问，继承中之类可以访问父类</li><li>default—&gt;默认的：同一个包能访问</li><li>第四章 面向对象三大特征—继承</li><li>1.继承的概念：父亲儿子，电影《西虹市首富》</li><li>2.继承的关键字：extends</li><li>3.继承的语法：</li><li>public class 类名  extends 父类{}</li><li>4.使用，在之类中：</li><li>可以直接调用父类的非私有属性和方法</li><li>可以用super.方法     super.属性</li><li>5.父类构造方法调用：super();</li><li>调用父类的构造方法必须在之类中调用</li><li>必须实在之类构造方法的第一行代码</li><li>6.重写@Override</li><li>必须继承</li><li>方法名一致，参数个数，顺序，类型全部一致<br> 第五章 面向对象（多态）</li><li>1.多态的概念</li><li>2.多态的必要条件</li><li>继承</li><li>重写</li><li>父类引用指向子类对象（向上转型）</li><li>3.多态的使用</li><li>public class Father{</li><li>public void cooking(){</li><li>System.out.println(“米饭”);</li><li>}</li><li>}</li><li>public class Son extends Father{</li><li>@Override</li><li>public void cooking(){</li><li>System.out.println(“熬粥”);</li><li>}</li><li>}</li><li>public class Test {</li><li>public static void main(String[] args) {</li><li>Father son=new Son();</li><li>son.cooking();</li><li>}</li><li>}</li><li>4.向下转型</li><li>Son son=(Son)father;</li><li>第六章 抽象</li><li>1.抽象的概念</li><li>2.抽象的关键字</li><li>abstract</li><li>可以修饰类，可以修饰方法</li><li>3.抽象的用法</li><li>//抽象类</li><li>public abstract class 类名{</li><li>//抽象方法没有方法体</li><li>public abstract void 方法名();    </li><li>}</li><li>//当父类是抽象类的时候，子类必须重写父类里面的抽象方法</li><li>4.final修饰符：最终的</li><li>修饰变量，修饰方法，修饰类</li><li>1.当修饰变量时，变量转换成常量，常量的值不能改变</li><li>final int a=18;//a=18;不能改变,必须给一个初始值</li><li>2.当修饰方法时，该方法不能被重写</li><li>3.当修饰类时，该类不能被继承</li><li>第七章 接口</li><li>1.接口的概念</li><li>2.接口的关键字</li><li>interface</li><li>3.接口的语法</li><li>public interface 接口名{}</li><li>File—&gt;new—&gt;interface//创建接口</li><li>4.接口的用法</li><li>实现接口的关键字  implements</li><li>public interface 接口名{</li><li>//接口是纯抽象类</li><li>//接口里面的方法都是抽象方法</li><li>void setData();</li><li>}</li><li>public class Play implements 接口名{</li><li>@Override</li><li>void setData(){</li><li>}</li><li>}</li><li>public class Test {</li><li>public static void main(String[] args) {</li><li>Play play=new Play();</li><li>play.setData();</li><li>}</li><li>}</li><li>注意接口可以进行多继承</li><li>public interface 接口名 extends 接口名，接口名{}</li><li>一般用法</li><li>public class 类名 extends 父类 implements 接口，接口{}</li><li>第八章 集合框架</li><li>1.ArrayList</li><li>1.用法</li><li>ArrayList list=new ArrayList();</li><li>list.add();//添加数据</li><li>list.get();//获取数据</li><li>2.Map</li><li>用法</li><li>Map map=new HasMap();</li><li>map.put(key,value);//key不能重复</li><li>map.get(key);//获取key对象的value</li><li>3.泛型</li><li>ArrayList<string> list=new ArrayList&gt;<string>();</string></string></li><li>Map&lt;String,String&gt; map=new HasMap&lt;String,String&gt;();</li><li>ArrayList&lt;Map&lt;String,String&gt;&gt; list=new ArrayList&gt;&lt;Map&lt;String,String&gt;&gt;();</li></ul>]]></content>
    
    
    <categories>
      
      <category>JAVA面向对象</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JAVA总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>